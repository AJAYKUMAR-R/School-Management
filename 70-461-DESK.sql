SELECT 10+25 AS RESULT;
SELECT 10/89 AS RESULT;
GO
SELECT 15-8 AS RESULT;
GO
--GO IS USED FOR BREAKING THE LINE BUNDULE
--STRIGHTWAY WE CAN MAKE THE CALCULATION PRINT USING SELECT
--TOOLS->OPTION-> TEXT EDITOR -> LINE NUMBER TO SHOW LINE OPTION


--USING GUI 
-- CREATE DATABASE -> RIGHT CLICK NEW DATABASE
-- CREATE TABLE -> RIGHT CLICK THE TABLE -> NEW TABLE
-- RIGHT CLICK ON THE TABLE TO SELECT TOP 1000 ROWS
-- RIGHT CLICK ON THE TABLE TO EDIT TOP 2000 ROWS TO ADD NEW DATA
-- TO THE COLUMN


--USING QUERY 
--TO CRAETE TABLE
CREATE TABLE TABLEONE (NAME NVARCHAR(25))
GO
-- INSERT DATA USING T-SQL
INSERT INTO TABLEONE VALUES ('KARTHICK'),('SURIYA');
--INSERT USING DATA SCHEMA SYNTAX DRAG AND DROP TEH TABLE IT WILL GIVE THE TABLE NAME 
-- WITH EXTENSION
INSERT INTO [dbo].[TABLEONE] VALUES ('KARTHICK'),('SURIYA');

--DELETE TABLE USING TRUNCATE IT WILL DELETE THE ROWS ONLY 
TRUNCATE TABLE [dbo].[TABLEONE];
SELECT * FROM TABLEONE;


--DATA TYPE
--IF I DID NOT ASIGN THE VALUE BUT I HAVE ADDED IT WILL SHOW NULL
DECLARE @MYVAR AS INT;
SELECT @MYVAR + 10 AS REUSLT

--IF I DID  ASIGN THE VALUE BUT I HAVE ADDED IT WILL SHOW THE OUT PUT 20
DECLARE @MYVARS AS INT = -2;
SELECT @MYVARS - 10 AS REUSLT;

--IF WE DECLARE THE VALUE AS 10.025 IT WILL PRINT AS 10 AFTERDECIMAL WILL
--LOST 


--DATA TYPES 
--BITS
--BIGINT 8 BYTES -9223372036854808 to 9223372036854808
--INT    4 BYTES -2147483648 to 214748364 
--SMALLINT 2 BYTES 30786 to -30786
--TINYINT  1 BYTES 0-255

--SMALL INT
DECLARE @SMALINT AS SMALLINT = 2200;
SELECT 2200*@SMALINT AS RESULT;

--TINYINT 
--IT WON'T WORK BECAUSE NEGATIVE VALUE NOT FOR TINYINT
--TINY INT WONT ACCEPT NEGATIVE VALUE
DECLARE @TINYINT AS TINYINT = -200;
SELECT @TINYINT;


--DECIMAL
--IT WILL STORE 12345 5 VALUE FROM THE RIGHT AND TWO VALUE FROM THE LEFT 
-- EX; 12345.25


DECLARE @DECIMAL AS DECIMAL(7,2);
---
--SET IS USED TO ASSIGN THE VALUES
SET @DECIMAL = 12345.258;

SELECT @DECIMAL 

---WE CAN INCREMENT THE VALUES AS WELL
SET @DECIMAL = 1000.98 + 1;

--TWO PIONTS TWO REMEMBER
--- IF I GAVE LESS VALUE LIKE 100.253
--- IT WILL WORK IF THE VALUE EXCEEDS OVER 7 IN THIS EXAMPLE IT WILL
--- THROW ARTHIMATIC EXCEPTION

SELECT @DECIMAL AS RESULT;


--WE SHOULD NEVER DELCARE THE VALUE LIKE THIS
DECLARE @NUMERIC AS NUMERIC(4)
SET @NUMERIC = 1000.0202;
SELECT @NUMERIC AS RESULT;
--IT SIMILAR LIKE INTEGERS
--1-9 => 5BYTES
--10-19 => 9BYTES
--20-28 => 13BYTES
--10-A9 VALUE WILL BE TOTAL NUMBERS
--LIKE 1000000000.12345678 TOTAL 19 PRECISION BYTES CONSUME WILL BE 13



--MONEY AND SMALLMONEY
--MONEY --8 BYTES (15,4) --WRONG IN DOCS
--SMALLMONEY --4 BYTES (6,4) -- 
DECLARE @MONEY AS MONEY = 123456789789456.235689; 
DECLARE @SMALLMONEY AS SMALLMONEY = 123456.235689;

SELECT @MONEY AS RESULT;
SELECT @SMALLMONEY AS SMALLRESULT;


---FLOAT AND REAL
---FLOAT 7 DIGITS - APART FROM THAT IT WILL CONVERT TO 12E6 LIKE EXPRESION
---ROUND OF PRECISION WE CAN USE
-- FLOAT 7 DIGITS 4 BYTES WILL ALLSO CALLED AS REAL
DECLARE @FLOAT AS FLOAT(3) = 12345678910112.205023241654654564564654;
SELECT @FLOAT AS RESULT;

--- WHEN I GAVE SIMPLY LIKE THIS
----123456789101112.1235 IT WILL STORE AS IT IS 

---IMPORTATANT NOTE
--The SQL Server Database Engine optimizes storage of bit columns. 
--If there are 8 or fewer bit columns in a table, the columns are stored as 1 byte. 
--If there are from 9 up to 16 bit columns, 
--the columns are stored as 2 bytes, and so on.
--The string values TRUE and FALSE can be converted to bit values: 
---TRUE is converted to 1 and FALSE is converted to 0.
--Converting to bit promotes any nonzero value to 1.


---TOPIC BUILT-INFUNCTION
SELECT POWER(2,2) AS RESULT;
SELECT POWER(2,0.5)  POWERRESULT;
SELECT SQRT(16) AS SQRTRESULT;
SELECT SQUARE(2) AS SQUARERESULT; 
GO


---FLOOR WILLL ALWAYS GOES TO LOWEST 3.8 TO 3
---CEILING WILLL ALWAYS GOES TO LOWEST 3.2 TO 4
---ROUND WILL ALWAYS GOES TO NEAEREST 3.2 TO 3.00 AND 3.8 TO 4.0
SELECT FLOOR(3.21) AS FLOORRESULT;
SELECT FLOOR(3.98) AS FLORRESULT;
SELECT CEILING(3.21) AS FLOORRESULT;
SELECT CEILING(3.98) AS FLORRESULT;
SELECT ROUND(3.21,0) AS FLOORRESULT;
SELECT ROUND(3.98,0) AS FLORRESULT;
GO
-- ABS WILL CONVERT NEGATIVE TO POSITIVE
-- SIGN WILL GIVE THE VALUES EITHER NEAGTIVE OR POSTIVE IF NEGATIVE MEANS -1 AND POSITIVE MEANS +1
SELECT ABS(3.25698) AS ABSRESULT;
SELECT ABS(-989) AS NEGATIVEABS;
SELECT SIGN(-989),SIGN(10) AS RESULTS;

--GLOBAL CONSTANTS 
SELECT PI() AS RESULT;
SELECT EXP(10) AS RESULT;

---TYPECASTING 

--IMPLICIT 
--IT WILL CONVERT TO MAJOR DATA TYPE WIHCH CAN STORE HIGH VALUES
SELECT 5.23/3 AS RESULT;


---EXPLICIT TWP WAYS 
--CAST(VALUE AS DATATYPE_TARGET),CONVERT(TARGET_DATAtYPE,VALUE);

SELECT CAST(8 AS DECIMAL(5,2)) AS RESULT;

---IT WILL THROW ARTHIMATIC EXCEPTION BECAUSE
--- DECIMAL(5,2) HIGHEST VALUE WILLL BE 999.99
--- IF I GAVE 1000 IT CAN'T CONVERT
SELECT CAST(1000 AS DECIMAL(5,2)) AS RESULT;

--CONVERT METHOD
SELECT CONVERT(decimal(5,2),49) AS RESULT;

--PRACTICE ACTIVITY 4
SELECT ROUND(4.153,1); 

---IF THIS EXCEED THE MAXIMUM LIMITS THEN WE
---SHOULD USE TRY_CAST OR TRY_CONVERT BECAUSE IT WILL RETURN NULL INSTEAD ERROR
---IF I WERE USING CAST IT WILL THROW ARTHIMATIC EXCEPTION
---IF THE DATA HAS NOT ASSIGNED ALL THE METHODS WILL RETURN NULL EXAMPLE 
---TRY_CAST() AND CAST() BOTTH 
DECLARE @VARS AS DECIMAL = 20000.25656;
SELECT TRY_CAST(@VARS AS tinyint) AS RESULT;
SELECT TRY_CONVERT(tinyint,@VARS) AS RESULT;

--WILL NOT WORK
SELECT CAST(@VARS AS tinyint) AS RESULT;


select system_type_id, column_id, system_type_id / column_id as Calculation
from sys.all_columns



--STRING DATA TYPE
--CHAR - ASCII
--VARCHAR - ASCII
--NVARCHAR - UNICODE
--NCHAR - UNICODE


--CHAR 
--IT IS FIXED LENGTH 
--EXAMPLE
--IN THIS EXAMPLE I HAVE GIVEN LESS VALE THAN THE LEN
--- THOUGH IT OCCUPIED 10 BYTES 
DECLARE @CHAR AS CHAR(10)
SET @CHAR = 'AJAY';
SELECT @CHAR AS STRING , LEN(@CHAR) AS LENGTHS , DATALENGTH(@CHAR) AS BYTESCONSUMED;

---BRECHES HE RANGE
--ALL THE  EXTRA VALUE WILL BE DROP OFF
DECLARE @CHARS AS CHAR(10)
SET @CHARS = 'AJAYKUMARRATHINAVELU';
SELECT @CHARS AS STRING , LEN(@CHARS) AS LENGTHS , DATALENGTH(@CHARS) AS BYTESCONSUMED;


--VARCHAR 
--VARCHAR WILL ONLY STORE ASCII VALUE IF WE GAVE THE LENGTH IT WILL
--ADD 2 BYTES EXTRA AND IT WILL STORE BYTES DYNAMICALLY
--BUT IT WONT SHOW IT IN THE TABLE INTERNALLY CONSUMED R&D
DECLARE @VARCHAR AS VARCHAR(10)
SET @VARCHAR = 'AJAY';
SELECT @VARCHAR AS STRING , LEN(@VARCHAR) AS LENGTHS , DATALENGTH(@VARCHAR) AS BYTESCONSUMED;

--NVARCHAR WILL ABLE TO STORE GREEK CHARACTER 
-- AT THE MEAN TIME WE SHOULD ADD THE N PREFIX BEFORE IT
-- IF N NOT ADDED IT WILL CONVERT IMPLICITLY TO CHAR

DECLARE @NCHAR AS NCHAR(10)
SET @NCHAR = 'அஜயஂ';
SELECT @NCHAR AS STRING , LEN(@NCHAR) AS LENGTHS , DATALENGTH(@NCHAR) AS BYTESCONSUMED;


--WITH THAT
--ADDED TWO BYTES FOR EACH DIGIT
--IN THIS EXAMPLE 2+2+2
---IF THIS NVARCHAR 2+2+2+ 2 R&D NEED TO DO
DECLARE @NCHARS AS NCHAR(10)
SET @NCHARS = N'அஜயஂ';
SELECT @NCHARS AS STRING , LEN(@NCHARS) AS LENGTHS , DATALENGTH(@NCHARS) AS BYTESCONSUMED;

--STRING FUNCTION
---TEXT AND NTEXT - OLD WAY OF DECLARING LIKE THAT 
---NTEXT IS NVARCHAR(MAX) 8000BYTES -- SIMILAR TO INFINITY -- UNICODE
---TEXT IS VARCHAR(MAX) 8000BYTES --- ASCII

DECLARE @NAME AS VARCHAR(20);
--IDEX WILL BE STRATS AT ONE
SET @NAME = '   AJAY KUMAR';

SELECT LEFT(@NAME,2) AS LEFTS , RIGHT(@NAME,2);
SELECT SUBSTRING(@NAME,5,2) AS SUBSTRINGS;
--TRIM LEFT AND RGHT
---TRIM() WILL LTRIM AND RTRIM IN 2017 GREATER VERSION
SELECT RTRIM(LTRIM(@NAME)) AS RESULT;
---TRIM ALL SIDES
SELECT REPLACE(@NAME,' ','')


---NULL
--MEANS SQL DONT WHAT IS THAT NOTHING WILL BE ASSIGNED
--OUTPUT NULL 
DECLARE @VARINT AS DECIMAL(5,2);


--WONT RUN INTO EXCEPTION RESULT WILL BE NULL
--TWO 
SELECT @VARINT + 1.02 AS RESULT; 
--WHEN WE CAST IT WILL THROWAN ERROR WE NEED TO
-- USE TRY CAST BOTH WILL RETURN NULL VALUE

SELECT CAST(@VARINT + 1.02 AS INT) AS RESULT; 

SELECT TRY_CAST(@VARINT + 1.02 AS INT) AS RESULT; 


---STRING CONCAT 
DECLARE @FIRSTNAME AS VARCHAR(20);
DECLARE @MIDDLENAME AS VARCHAR(20);
DECLARE @LASTNAMENAME AS VARCHAR(30);

SET @FIRSTNAME = 'AJAY';
--SET @MIDDLENAME = 'KUMAR';
SET @LASTNAMENAME = 'RATHINAVELU';

---CONCAT CAN BE DONE USING + 
SELECT (@FIRSTNAME + ' ' + @MIDDLENAME + ' ' + @LASTNAMENAME) AS FULLNAME;

--IF ANY ONE HAS NOT BEEN DECLARE IT WILL THROW NULL
SELECT (@FIRSTNAME + ' ' + @MIDDLENAME + ' ' + @LASTNAMENAME) AS FULLNAME;

--TO RESOLVE ABOVE ISSUE IFF
SELECT (@FIRSTNAME + ' ' + IIF(@MIDDLENAME IS NULL,'',' ' + @MIDDLENAME) + ' ' + @LASTNAMENAME) AS FULLNAME;


---ANOTHER WAY 
SELECT @FIRSTNAME + ' ' + CASE WHEN @MIDDLENAME IS NULL THEN '' ELSE @MIDDLENAME + ' ' END + @LASTNAMENAME;

--YET A ANOTHER WAY 
SELECT (@FIRSTNAME + ' ' + COALESCE('',@MIDDLENAME) + ' ' + @LASTNAMENAME) AS FULLNAME;

--YET A ANOTHER WAY 
SELECT CONCAT(@FIRSTNAME,' '+ @MIDDLENAME ,' '+ @LASTNAMENAME) AS FULLNAME;

--NEED TO DO R&D BEFORE USING IT 

-- STANDARD NUMERIC FORMAT 
--WHEN CCANCAT STRING TO INTEGER IT WILL THROW 
--ERROR CANT CANVERT VARCHAR TO NUMERIC 
--THERE WE SHOULD USE CAST OR CONVERT

SELECT 'MY SALARY IS : ' + 12132456454.366
SELECT 'MY SALARY IS : ' + CAST(12132456454.366 AS VARCHAR(45))

--- WHEN WE NEED TO PROVIDE ACTUAL MONEY TO THE CLIENT
-- WE CAN USE FORMAT() NO NEED TO SPECIFY TYPE BECAUSE OUTPUT WILL BE 
-- STRING


--IT WILL TAKE CARE THE cOUNTRY FORMAT 
--IF WE DID NOT SPECIFY ANY CLUTURE LIKE EN-US IT WILL FIND THEIR 
--CULTUE
SELECT 'MY SALARY IS : ' + FORMAT(12132456454.366,'C','en-US');
SELECT 'MY SALARY IS : ' + FORMAT(12132456454.366,'C','en-gb');
SELECT 'MY SALARY IS : ' + FORMAT(12132456454.366,'C','DE-DE');

---PRACTICE QUESTION 
select [name]
from sys.all_columns

--ADD THE A TO END
SELECT CONCAT([NAME],N'Ⱥ') FROM SYS.all_columns;

--FIRST CHARACTER
SELECT SUBSTRING([NAME],2,LEN([NAME])) FROM SYS.all_columns;

--LAST CHARACTER
SELECT SUBSTRING([NAME],1,LEN([NAME])-1) FROM SYS.all_columns;


--DATE TYPE
--IT WILL CONSUME 
-- IT SUGGESTED THAT TRY TO USE TIME,DATE,DATETIME2,DATETIMEOFFSET
--WHICH IS VERY USEFULL AND PROVIDE MORE PRECISION 
---0.003 SEC PRECISED
DECLARE @DATETIME AS DATETIME;
SET @DATETIME = '2987-08-12 12:30:28.164';
SELECT @DATETIME;

GO
--IT WILL BE MORE PRECISE
--WE CAN GIVE UPTO 5 PRECISION VALUE 
--1-2 WILLL TAKE 6 BYTES 
--2-3 WILLL TAKE 7 BYTES 
--=4-5 WILLL TAKE 8 BYTES

--NEED TO R&D DATE AND TIME SO MANY THINGS CHANGED

DECLARE @DATETIME2 AS DATETIME2(5);
SET @DATETIME2 = '2987-08-12 12:30:28.164';
SELECT @DATETIME2;

---EXTRACT HOUR AND DAY AND TIME
SELECT YEAR(@DATETIME2) AS YEAR,MONTH(@DATETIME2) AS MONTH , DAY(@DATETIME2) AS DAY;


----DATE METHODS
--- IT WILL GET THE CURRENT DATE AND TIME 
--- GETDATE() DATE WITH 0.003 CURRENT_TIMESTAMP() PRECISION
--- SYSDATE_TIMESTAMP() WILL BE HIGH PRECISION 0.0000007 DATETIME2
SELECT GETDATE() AS TODAY;
SELECT CURRENT_TIMESTAMP AS TODAY;
SELECT SYSDATETIME() AS TODAY;


---METHODS
SELECT DATEADD(YEAR,1,'2029-07-8 12:30:20.157') AS ADDEDTIME;
SELECT DATEPART(HOUR,'2029-07-8 12:30:20.157') AS PARTDATE;
SELECT DATENAME(WEEKDAY,'2029-07-8 12:30:20.157') AS DATENAMES;

SELECT DATEADD(DAY,-1,'2015-01-01') 

---IT WILL RETURN INT MILLI SECOND WON'T WORK
---INSTED RETURN SECONF,HOURS,MONTH,YEAR 
---IT WILL RETURN DIFFERENCE
SELECT DATEDIFF(SECOND,'2018-07-8 12:30:20.157',GETDATE()) AS TIMEELAPSED;


---DATE TIME OFFSET WILL PROVIDE THE TIMEZONE
--IT WILL TAKE AROUND 8 TO 10 BYTES

DECLARE @DATETIMEOFFSETS AS  DATETIMEOFFSET(2) = '2029-07-8 12:30:20.157 +5:30';

SELECT @DATETIMEOFFSETS;



DECLARE @DATETIME2S AS DATETIME2 = '2029-07-8 12:30:20.157';
--IT WILL PROVIDE THE SAME TIME BUT IT CONCAT GMT TIME
SELECT TODATETIMEOFFSET(@DATETIME2S,'+05:30');

---GET CUREENT DATETIMEOFFSET
SELECT SYSDATETIMEOFFSET() AS OFFSETTIMEWITHGMT;

---DO R&D
SELECT SYSUTCDATETIME() AS DATETIMEWITH24HOURS;

---IT WILL CONCAT
SELECT DATETIMEOFFSETFROMPARTS(2016,01,12,1,2,3,4.136,5,30,3) AS DATETIMEOFF;

---SWITCHOFFSET R&D

---CONVERT DATETIME
DECLARE @DATES AS DATETIME2;
SET @DATES = GETDATE();

---WE CON'T CONVERT DATE TO STRING BECAUSE PRECEDENCE DATA TYPE ISSUE WILL OCCUR
--SELECT 'TODAY DATE IS ' + @DATES AS TODAYDATE;

---INSTAED WE CAN CONCAT USING CONVERT AND CAST
---CONVERT THIRD PARAMETER WILL BE THE STYLE 
---102 -2023.04.06
---104 WILL BE / 2023/04/06
SELECT 'TODAY DATE IS ' + CONVERT(NVARCHAR(MAX),@DATES,102) AS TODAYDATE;

--CONVERT INTO STANDARD DATE WHEN IT'S IN THE ENGLISH WORDS FORMAT 
--THERE CONVERT CAN'T DO
SELECT CONVERT(datetime2,'THURSDAY 25 JUNE 2015') AS OUTPUTS;

---THERE WE SHOULD USE PARSE
---INSTEAD OF THURSDAY WE MENTION AS A FRIDAY WE WILL ENDED UP IN GETTING
--- ERROR THIS SHOULD BE MORE ACCURATE
SELECT PARSE('THURSDAY 25 JUNE 2015' AS datetime2) AS OUTPUTS;


---DATE FORMATTING WE SHOULD USE FOR FORMATING DATE


---D WILL RETURN LONG FORMAT LIKE THIS THURSDAY 25 JUNE 2015
SELECT FORMAT(PARSE('THURSDAY 25 JUNE 2015' AS datetime2),'D') AS RESULT;

--THURSDAY 25 JUNE 2015 LIKE THIS YOU NEED TO CONVERT THERE ONLY WE CAN ADD CULTURE
SELECT FORMAT(CAST('2023-06-04' AS datetime2),'D','de-DE') AS RESULT;

---MM MUST GIVEN mm -- WILL BE CONSIDERED AS MINUTES
SELECT FORMAT(PARSE('THURSDAY 25 JUNE 2015' AS datetime2),'dd-MM-yyyy') AS RESULT;

---WILL RETURN SHORT FORMAT
SELECT FORMAT(PARSE('THURSDAY 25 JUNE 2015' AS datetime2),'d') AS RESULT;


---CREATE TABLE 
USE [70-461];
CREATE TABLE EMPLOYEETABLE
(
  NAMES VARCHAR(25) NULL,
  EMPLOYEEID INT NULL,
  DATEOFBIRTH DATE,
  DEPARTMENT CHAR(12)
)

--ADDING COLUMN TO THE EXISTING TABLE
-- ALTER TABLLE DOES NEED TO SPECIFIY COLUMN 
-- DROP NEED TO SPECIFY COLUMN 
ALTER TABLE EMPLOYEETABLE 
ADD ISOID BIGINT; 

--DROP THE COLUMN
ALTER TABLE EMPLOYEETABLE 
DROP COLUMN ISOID; 

--ALTER THE EXISTING DATA TYPE
ALTER TABLE EMPLOYEETABLE 
ALTER COLUMN DEPARTMENT CHAR(10);



---PATTERN CHECKING 
--LIKE OPERATOR 
--% - INFINATE -W% - STRATSWITH 
-- __EXACTMATCH - A__Y => AJAY OUTPUT 
---[A-G] --IN THE TRAGET A TO G ANY THING IN BETWEEN AND INCULDES A AND G
--[AQG] EITHER A,G OR Q 
--[^AQG ] EXCEPT AQG


USE [70-461];

SELECT NAMES FROM EMPLOYEETABLE WHERE NAMES LIKE '[%]%';
SELECT NAMES FROM EMPLOYEETABLE WHERE NAMES LIKE 'A%';

SELECT * FROM EMPLOYEETABLE;

--CREATE TABLE 

CREATE TABLE DATAS 
(
EmployeeNumber INT NOT NULL,
EmployeeFirstName VARCHAR(25)  NULL,
EmployeeMiddleName VARCHAR(25) NULL,
EmployeeLastName  VARCHAR(25)  NULL,
EmployeeGovernmentID CHAR(15) NOT NULL,
DateOfBirth DATETIMEOFFSET  NOT NULL,
Department VARCHAR(25) NULL
)


---SELECTING ROWS

---EQUAL
SELECT * FROM DATAS 
WHERE EmployeeNumber = 200;


--NOT EQUAL
SELECT * FROM DATAS 
WHERE EmployeeNumber != 200;

SELECT * FROM DATAS 
WHERE EmployeeNumber <> 200;

---BETWEEEN
SELECT * FROM DATAS 
WHERE EmployeeNumber BETWEEN 200 AND 209;

SELECT * FROM DATAS 
WHERE EmployeeNumber >= 200 AND EmployeeNumber <=209;

---NOT OPERATOR
SELECT * FROM DATAS 
WHERE NOT (EmployeeNumber >= 200 AND EmployeeNumber <=209);

SELECT * FROM DATAS 
WHERE NOT EmployeeNumber  BETWEEN 200 AND 209;


---IN OPERATOR
SELECT * FROM DATAS
WHERE EmployeeNumber IN (209,204,219);


SELECT * FROM DATAS
WHERE EmployeeNumber NOT IN (209,204,219);


--OR OPERATOR
SELECT * FROM DATAS 
WHERE EmployeeNumber >= 200 OR EmployeeNumber <= 209;


---COMPARE DATES

SELECT * FROM DATAS
WHERE DateOfBirth >= '19780101' AND DateOfBirth <= '20021102';

--EXPECT THAT RANGE
SELECT * FROM DATAS
WHERE NOT (DateOfBirth >= '19780101' AND DateOfBirth <= '20021102');

---NOT USE THIS R&D
SELECT * FROM DATAS
WHERE YEAR(DateOfBirth) BETWEEN 1976 AND 1988;


--GROUP BY WITH HOW IT READ SQL ENGINE
---FROM DATAS -- READ THE TABLE
--WHERE 1=1 -- IMPLICTLY ADD THIS CONDITION
--GROUP BY YEAR(DATAS.DateOfBirth); -- GROUP THE TABLE ACCORDING TO THE CODE
--SELECT YEAR(DATAS.DateOfBirth) AS DATEOFBIRTHS , COUNT(*) AS EACHYEARCOUNT --THEN IT PERFOR AGGREGATE FUNCTION
---SO THATS WHY IF MENTION THE ALIAS NAME IN GROUPBY CLAUSE IT WON'T WORK 
---EXAMPLE IT WONT WORK
SELECT
YEAR(DATAS.DateOfBirth) AS DATEOFBIRTHS , COUNT(*) AS EACHYEARCOUNT
FROM
DATAS
WHERE 1=1
GROUP BY YEAR(DATEOFBIRTHS);


SELECT
YEAR(DATAS.DateOfBirth) AS DATEOFBIRTHS , COUNT(*) AS EACHYEARCOUNT
FROM
DATAS
WHERE 1=1
GROUP BY YEAR(DATAS.DateOfBirth);


--WE CAN'T GAURENTED WILL GET THE DATA IN THE SAME ORDER EVERY TIME --IT IS CALLED NOT deterministic
--SO THER WE CAN USE ORDERBY CLAUSE


--GROUPBY,HAVING ,ORDERBY HOW IT READS
SELECT LEFT(DATAS.EmployeeLastName,1) AS FIRSTLLETTER , COUNT(*) AS TOTALCOUNT 
FROM DATAS 
WHERE DATAS.DateOfBirth > '19860101'
GROUP BY LEFT(DATAS.EmployeeLastName,1)
HAVING COUNT(*) >= 20
ORDER BY COUNT(*) ASC;
---HERE FIRST COLLECT 
--SELECT LEFT(DATAS.EmployeeFirstName,1) AS FIRSTLLETTER , COUNT(*) AS TOTALCOUNT -5. THEN SELECT THE TABLE
--FROM DATAS - 1 TABLE
--WHERE DATAS.DateOfBirth = '198700101' -- 2. FITERS DATES ONLY IN THE TABLE
--GROUP BY COUNT(LEFT(DATAS.EmployeeFirstName,1)) -- 3. IN THAT FILTERED TABLE COUNT FIRST LETTER
--HAVING COUNT(*) >= 20 -- 4. SORTED THAT COUNT WHICH IS GREATER THAN THE 20
--ORDER BY COUNT(*) ASC; -- THEN IT WILL OREDER THE DATA SO THAT WE CAN USE THE ALIAS NAME IN THE ORDER BY


-----PRACTISE SOLUTION
Update DATAS
Set EmployeeMiddleName = NULL
Where EmployeeMiddleName = '';

SELECT * FROM DATAS;


--WE CAM'T SELECT ALL THE RESULT WE CAN SELECT 
--THE RESULT WHICH GET GROUP BY RESULT
SELECT DATAS.EmployeeMiddleName,COUNT(DATAS.DateOfBirth)
FROM DATAS 
GROUP BY MONTH(DATAS.DateOfBirth);

---BY COOREECTING THE ABOVE QUERY
--REULT WE CAN GET THE DATA OF 
SELECT COUNT(DATAS.DateOfBirth),COUNT(DATAS.Department)
FROM DATAS 
GROUP BY MONTH(DATAS.DateOfBirth);

--IMPORTANT NOTE THAT COUNT WILL ONLY CALCULATES THE VALUE WHICH HAS NOT NULL TYPE
---SO THATS WHY HERE GET  EMPLOYEE COUNT  ON THE SPECIFIC MONTH THEN - EMPLOYEE WHO HAS MIDDLE NAME
--- THEN WE CAN GET REST OF VALUES WHICH HAS NULL IN IT.
SELECT 
DATENAME(MONTH,DATAS.DateOfBirth) AS LONGNAME,
COUNT(*) AS NOOFCOUNT,
COUNT(DATAS.EmployeeMiddleName) AS MIDDLENAMEPRESENT,
COUNT(*) - COUNT(DATAS.EmployeeMiddleName) AS NULLABLEMIDDENAME
FROM DATAS
GROUP BY MONTH(DATAS.DateOfBirth),DATENAME(MONTH,DATAS.DateOfBirth)
ORDER BY MONTH(DATAS.DateOfBirth);

--ANOTHER WAY
SELECT DATENAME(MONTH,DATAS.DateOfBirth) AS GROUPBYDOBMONTH,COUNT(*) AS NOOFCOUNT
FROM DATAS
GROUP BY  DATENAME(MONTH,DATAS.DateOfBirth)
ORDER BY GROUPBYDOBMONTH;


--- IN THAT RESULT I WANT GET THE MINIMAM AND MAXIMAM DATE
SELECT 
DATENAME(MONTH,DATAS.DateOfBirth) AS LONGNAME,
COUNT(*) AS NOOFCOUNT,
COUNT(DATAS.EmployeeMiddleName) AS MIDDLENAMEPRESENT,
COUNT(*) - COUNT(DATAS.EmployeeMiddleName) AS NULLABLEMIDDENAME,
FORMAT(MIN(DATAS.DateOfBirth),'dd-MM-yyyy') AS MINIMAMDATE,
FORMAT(MAX(DATAS.DateOfBirth),'D') AS MAXMIAMAMDATE
FROM DATAS
GROUP BY MONTH(DATAS.DateOfBirth),DATENAME(MONTH,DATAS.DateOfBirth)
ORDER BY MONTH(DATAS.DateOfBirth);

---CREATE ANOTHER TABLE
CREATE TABLE TRANSAC
(
AMOUNT SMALLMONEY NOT NULL,
DATEOFFTRANSACTION SMALLDATETIME NULL,
EMPLOYEENUMBER INT NOT NULL
)

--JOINS IN THE MSSQL DATABASE
--HERE AGAIN THE IMPORTANT NOTE THAT WHEN WE PERFORM GROUP BY
--WE SHOULD ADD OTHER COLUMNS EXCEPT AGGREGATE FUNCTION
--IN GROUP BY CLAUSE THEN ONLY WE CAN EXTRACT THE CLUMN IN THE RESULT


--HOW IS THAT POSSIBLE
--IN THIS EXAMPLE JOINING THE TABLE, BY EMPLOYEENUMBER RESULT BOTH EMPLOYEENMBER PRESENT IN BOTH TABLE
--IN THAT GROUP BY, NUMBER AND NAME OF EMPLOYEE IT WILL GROUP THE DUPLICATES NAME TO
--SINGLE NAME AND DUPLICATE NUMBER TO THE 
--SINGLE NUMBER THEN ONLY WE CAN GET THE COLUMNN IN THE RESULT
--AT THE TIME SUM() IS POSSIBLE
--NAME CANT GET OUTSIDE FAILED  QUERY

SELECT
DATAS.EmployeeFirstName,
DATAS.EmployeeNumber,
SUM(TRANSAC.AMOUNT) AS TOTALITY
FROM 
DATAS
INNER JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATAS.EmployeeNumber
ORDER BY DATAS.EmployeeNumber;

--PASSED QUERY
SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = 658;


SELECT
DATAS.EmployeeFirstName,
DATAS.EmployeeNumber,
SUM(TRANSAC.AMOUNT) AS TOTALITY
FROM 
DATAS
INNER JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATAS.EmployeeNumber,DATAS.EmployeeFirstName
ORDER BY DATAS.EmployeeNumber;

SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = 658;


---	CREATING NEW TABLE USING INTO QUERY
---TO SELECT THE DISTINCT VALUE WE CAN USE DISTINCT


--THIS IS THE OPTIMUM SOLUTION
SELECT 
DISTINCT DATAS.Department
FROM 
DATAS;

--WHEN WE ADD ANOTHER COLUMN WE CAN NOT GET THE DISTINCT VALUE
--IT JUST BECAUSE OF EACH DEPARTMENT EMPLOYEE HAS DIFFERENT NAME
SELECT 
DISTINCT DATAS.Department,DATAS.EmployeeFirstName
FROM 
DATAS;

--CREATING THE TBALE USING INTO KEYWORKD IT SHOULD BE PLACED AFTER 
--THE KEYWORD SELECT AND BEFOR FROM

SELECT 
DISTINCT DATAS.Department,'' AS EMPTYCOLUMN
INTO DATASINTO
FROM 
DATAS;

---THE SAME DATTYPE AND CONTRAINTS WILL CREATE 
--FOR NEW TABLE WE CAN ALTER USING ALTER QUERY
--WHILE DECLARE IT WE AN CONVERT THE TYPE LIKE THIS

SELECT 
DISTINCT DATAS.Department,CONVERT(NVARCHAR(20),'') AS EMPTYCOLUMN
INTO DATASINTO
FROM 
DATAS;

--THREE TABLE JOINS 
SELECT 
DATAS.Department,SUM(TRANSAC.AMOUNT) AS DEPARTEMENTWISETOTAL
FROM DATAS
INNER JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATAS.Department;


--USNING THREE TABLES
SELECT 
DATASINTO.Department,SUM(TRANSAC.AMOUNT) AS DEPARTEMENTWISETOTAL
FROM DATASINTO
LEFT JOIN
DATAS
ON DATASINTO.Department = DATAS.Department
LEFT JOIN
TRANSAC 
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATASINTO.Department;


---THE EMPLOYEE WHICH HAS NOT DO ANY TRANSACTION
SELECT 
DATAS.EmployeeFirstName,DATAS.EmployeeLastName,SUM(TRANSAC.AMOUNT),DATAS.EmployeeNumber
FROM
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER 
GROUP BY DATAS.EmployeeNumber, DATAS.EmployeeFirstName,DATAS.EmployeeLastName,DATAS.EmployeeNumber
HAVING SUM(TRANSAC.AMOUNT) IS NULL

---TO JUSTIFY THE ABOVE QUERY
SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = 130

---BEGAIN TRANSACTION ROLLBACK TRANSACTION

SELECT  
*
FROM 
DATAS
LEFT JOIN
TRANSAC 
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE TRANSAC.EmployeeNumber IS NULL;

--WE CAN'T GET OUTPUT IN THIS CODE
SELECT  
DATAS.EmployeeNumber
FROM 
DATAS
RIGHT JOIN
TRANSAC 
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber IS NULL
GROUP BY TRANSAC.EMPLOYEENUMBER,DATAS.EmployeeNumber



---
---TRNSACTION CONCEPT

GO
---IMPORTANT NOTE
--WE CAN USE GROPBY WITHOUT AGGREGATE FUNCTION
--EXAMPLE
SELECT  
DATAS.EmployeeNumber
FROM 
DATAS
RIGHT JOIN
TRANSAC 
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber IS NULL
GROUP BY TRANSAC.EMPLOYEENUMBER,DATAS.EmployeeNumber
--IN THE ABOVE EXAMPLE IT JUST FETCH THE DATA WITHOUT AGGREGATE FUNCTION BUT 
--WE SHOULD ADD THE COLUMN IN GROUP BY CLAUSE WHICH EVER COLUMN YOU WANT TO SEE IN THE OUTPUT 


--WE CAN USE AGGREGATE FUNCTION WITHOUT GROUP BY
--IF THE TABLE EMPLOYEE NUMBER HAS ANY DUPLICATES 
--IT SHOULLD GROUP THEN IT SHOULD DELETE
--IN THIS EXAMPLE NO DUPLICATE THATS WHY COUNT() IT DIRECTLY
--EMPLOYEE NUMBER ARE UNIQUE
--EXAMPLE
SELECT COUNT(EmployeeNumber) FROM DATAS;
GO
---TRANSACTION CONCEPT
BEGIN TRANSACTION

SELECT COUNT(EmployeeNumber) FROM DATAS;


DELETE FROM
DATAS
WHERE 
DATAS.EmployeeNumber
IN
(SELECT
DATAS.EmployeeNumber
FROM
(SELECT
SUM(AMOUNT) AS TOTALSUM , TRANSAC.EMPLOYEENUMBER AS EMPLOYNUMBER
FROM 
DATAS
RIGHT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY TRANSAC.EMPLOYEENUMBER) AS EMP1
RIGHT JOIN DATAS
ON EMP1.EMPLOYNUMBER = DATAS.EmployeeNumber
WHERE EMP1.EMPLOYNUMBER IS NULL);
 
SELECT COUNT(EmployeeNumber) FROM DATAS;

ROLLBACK TRANSACTION

GO


--ORDER BY WON'T WORK FOR DERIVED TABLE WHICH MEANS SUBQUERY
--IF SUBQUERY RETURN TABLE CAN NOT ORDER IT R&D NO VALID EXAMPLE

SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = 130;

SELECT * FROM DATAS;

GO

--TO REMEMBER DELETE AND UPDATE STATEMENT

--DELETE (HOW MANY TABLE)
--FROM 
--TABLE NAME
--WHERE


--UPDATE (HOW MANY TABLE)
--SET
--FROM
--TABLENAME
--WHERE

--GROUP BY
--SELECT
--FROM
--TABLE
--WHERE
--GROUP BY
--HAVING
--ORDER BY

---INSERTE,DELETED THOSE ARE TEMPRORY TABLES
--INSERTED WILL HAVE NEW DATA WHEREAS DELETED WILL HAVE OLDDATA
-- APPLICABLE FOR INSERT,UPDATE,AND DELETE STATEMENT
GO
BEGIN TRANSACTION

UPDATE TRANSAC
SET TRANSAC.EMPLOYEENUMBER = 139
OUTPUT inserted.EMPLOYEENUMBER,deleted.EMPLOYEENUMBER
FROM TRANSAC
WHERE TRANSAC.EMPLOYEENUMBER = 3;

ROLLBACK TRANSACTION;
GO


---CONSTRAINTS
--WHEN EVER I AM INSERTING BUNCH VALUE IN A SINGLE STATEMENT IT WILL
--FAILED TO CONSTRAINT BREACHES AT THE TIME NOT INSERT A VALID DATA AS WELL
INSERT INTO DATAS(EmployeeGovernmentID) VALUES(NULL),(2000);


--NEW TAKE AWAY THE RETURN SELECT STATEMENT VALUE CAN BE INSERTED IN ANOTHER TABLE 
--WITHOUT USING VALUE KEY WORD IN INSERT COMMAND
INSERT INTO DATAS (EmployeeGovernmentID)
SELECT null FROM DATAS;


--ADDING COLUMN TO THE EXISTING TABLE
-- ALTER TABLLE DOES NEED TO SPECIFIY COLUMN 
-- DROP NEED TO SPECIFY COLUMN 
ALTER TABLE EMPLOYEETABLE 
ADD ISOID BIGINT; 

--DROP THE COLUMN
ALTER TABLE EMPLOYEETABLE 
DROP COLUMN ISOID; 

--ALTER THE EXISTING DATA TYPE
ALTER TABLE EMPLOYEETABLE 
ALTER COLUMN DEPARTMENT CHAR(10);



--ALTER STATEMENT QUERY REMEMBERANCE

---ADD COLUMN NO NEETD OF COLUMN NAME
--ALTER TABLE DATAS
--ADD NEWCOL VARCHAR(20);

---ALTER TABLE DATAS
--ADD COLUMN EXSITING COLUMN NAME CHAR(10)

--DROP COLUMN
--ALTER TABLE DATAS
--DROP COLUMN EXSITING COLLUMN NAME
--

--ADD CONSTRAIN CONTRAIN NAME TYPE (COLUMNNAME)
ALTER TABLE DATAS
ADD CONSTRAINT constrainname UNIQUE (EmployeeGovernmentID) ;

--DROP CONSTRINTS 
ALTER TABLE DATAS
DROP CONSTRAINT CONSTRAINNAME;

--WE CAN CREATE THE CONSTRAIN WHILE CREATING THE TABLE
--ADDING MULTILPE CONSTRAINT
CREATE TABLE CONSTRAINTABLE(
NAMES VARCHAR(20),
DOB DATE,
AGE INT,
CONSTRAINT CONSTRAINNAME1 UNIQUE(DOB,NAMES)
)

--WE CAN BEGIN THE TRANSATION AT THE TIME WE CAN COMMIT AND ROLLBACK
BEGIN TRAN

COMMIT TRAN

--DEFAULT CONSTRAINT
--IT WILL ALLOW THE USER TO INSERT THEIR REQUIRED DATA WHEREAS IT NOT GIVEN IT WILL ADD THE DEAFULT DATA


ALTER TABLE TRANSAC
ADD DATEOFTRANSAC DATETIME2;

--THIS IS THE SYNTAX FOR ADD THE TABLE CONSTRAINT
ALTER TABLE TRANSAC 
ADD CONSTRAINT DEFDEFAULLTCONSTRAIN DEFAULT GETDATE() FOR DATEOFTRANSAC;

--WHEN I WANT TO DELETE THE COLUMN I SHOULD DELETE THE CONSTRAINT BEFOR THEREAFTER 
--I SHOULD DELETE THAT
ALTER TABLE TRANSAC 
DROP CONSTRAINT DEFDEFAULLTCONSTRAIN;

ALTER TABLE TRANSAC 
DROP COLUMN DATEOFTRANSAC;

--WHEN EVER USER FORGRT TO INSERT THE VALUE THAT TIME DEFAULT VALUE WILL BE INSERTED
--IF YOU INSERT NULL VALUE IT WILL INSERT NULL VALUE ONLY
INSERT INTO  TRANSAC VALUES (2001,'2020/01/01',131,'2012/02/01');
INSERT INTO  TRANSAC(AMOUNT,DATEOFFTRANSACTION,EMPLOYEENUMBER) VALUES (1,'2010/01/01',131);
INSERT INTO  TRANSAC VALUES (150,'2017/01/01',131,NULL);

SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = 131;



--CONSTRAINT NAME SHOULD BE DIFFERENT THOUGH IT'S IN THE DIFFERENT TABLE
--R&D I HOPE DIFFRENT DATABASE IT WON'T MATTER

CREATE TABLE TRANSAC2
(
NAMES VARCHAR(20),
AGE INT,
DETEOFENTRY DATETIME NULL  CONSTRAINT DEFDEFAULTCONSTRAINT DEFAULT GETDATE()
);

--CHECK CONSTRAINT
-- IT WILL THROW ERROR CALLED CONFLICTS ERROR
-- IT JUST BECAUSE LIKE UNIQUE CONSTRAINTS. IF COLUMN HAS DUPLICATE VALUE THEN WE CAN'T APPLY CONSTRAINT
-- THIS COLUMN WHICH  BREACHES THE CONSTRAINT(DEFCHECKCONSTRAINT) SO IT WILL THROW THIS ERROR 
ALTER TABLE TRANSAC 
ADD CONSTRAINT DEFCHECKCONSTRAINT CHECK(AMOUNT BETWEEN -1000 AND 1000);

--  R&D ABOUT INSERTED AND DELETED TABLES IN DELETE QUERY
BEGIN TRAN
DELETE
FROM TRANSAC
WHERE TRANSAC.AMOUNT =(SELECT AMOUNT FROM TRANSAC  WHERE AMOUNT > 1000);
COMMIT TRAN

--ADDING CONSTRAINT FOR STRING
--REPLACE FUNCTION WILL RETURN STRING OF THAT COLUMN IF IT DEALS WITH NULL IT WILL RETURN NULL
--WITH NO CHECK DEFINES THAT CHECK CONSTRAINT WILL APPLICABLE FOR ONLY THE NEW ROW NOT EXSITTING ONES 
ALTER TABLE DATAS WITH NOCHECK
ADD CONSTRAINT DEFSTRINGCHECKCONSTRAINT 
CHECK (REPLACE(EmployeeMiddleName,'.','') =  EmployeeMiddleName OR  EmployeeMiddleName IS NULL)

--NOW I CANT INSERT A DATA WITH MIDDLE NAME HAS DOT IN IT
--IT WILL SHOW CONSTRAINT ERROR
INSERT INTO DATAS VALUES (20001,'AJAY KUMAR','R.','','QUZ123456','09/17/2000','SALES')

--IT WILL INSERT THE DATA
INSERT INTO DATAS VALUES (20001,'AJAY KUMAR','R','','QUZ123456','09/17/2000','SALES'); 

SELECT DATAS.EmployeeMiddleName FROM DATAS;

--WHILE CREATING THE TABLE THAT TIME DESCRIBE THE CONSTRAINT CHEK
--BY USING THE BELOW SYNTAX WE CAN CREATE WITH CONSTRAINT NAME IN IT 
CREATE TABLE CHECKCONS
(
NAMES VARCHAR(20) NULL,
MIDDLENAME VARCHAR(20) NOT NULL,
CONSTRAINT DEFCHECKCONSTRAINTWHILECREATE CHECK (REPLACE(MIDDLENAME,'.','') = MIDDLENAME OR MIDDLENAME IS NULL)
)

-- WE CAN DELETE THE CONSTRAINT
ALTER TABLE DATAS
DROP CONSTRAINT DEFSTRINGCHECKCONSTRAINT;

--CREATE THE PRIMARY KEY CNSTRAINTS

--ADDING PRIMARY KEY TO THE EXSISTING TABLE
ALTER TABLE DATAS
ADD CONSTRAINT DEFPRIMARYKEY PRIMARY KEY (EmployeeNumber);

-- CERATE TABLE WITH CONSTRATINT IN IT 
-- THIS WILL CREATE A AUTO NUMBERED COLUMN
CREATE TABLE PRIMARYCONSTRAINT
(
NAMES VARCHAR(25),
EMPLOYENUMBER INT PRIMARY KEY IDENTITY(1,1)
)


INSERT INTO PRIMARYCONSTRAINT
VALUES ('AJAY'),('VIJAY')


--WHEN I DELETE ALL THE ROW THEN I INSERTED DATA IDENTIY COLUMN  WILL BE CONTINUES THE NEW  VALUE
--IF I USE TRUCATE SATEMENT IT WILL START FROM THE BEGINING
-- SO TRUNCATE DROPS THE TABLE AND RE-CREATE THE COLUMN STRUCTURE
-- DELETE WITHOUT WHERE CONDITION WILL DELETE ONLY THE ROWS


DELETE FROM PRIMARYCONSTRAINT;

SELECT * FROM PRIMARYCONSTRAINT;

--WE CAN'T NSERT THE DATA IN THE IDENTITY COLUMN  
-- ERROR WILL THROW AN EXPLICIT IDENTITY FOR SPECIFIC COLUMN
INSERT INTO PRIMARYCONSTRAINT(NAMES,EMPLOYENUMBER) VALUES('DHANUSH',45);

--TO INSERTHE DATA IN IDENTITY COLUMN USE THIS
--IDENTITY INSERT WILL WORK WHEN PRIMARYCONSTRAINT IS ON AT THE MEAN TIME COLUMN SHOULD BE DISPLAYED
SET IDENTITY_INSERT PRIMARYCONSTRAINT  ON
INSERT INTO PRIMARYCONSTRAINT(NAMES,EMPLOYENUMBER) VALUES('DHANUSH',45);
SET IDENTITY_INSERT PRIMARYCONSTRAINT  OFF

--INTRO TO FUNCTION IN SQL

--BOTH OF THE FUNCTION WILL RETURN THE VALUE OF LAST IDENTITY WORKED FOR TABLE 
SELECT @@IDENTITY;
SELECT SCOPE_IDENTITY();


---THIS FUNCTION WILL RETURN THE IDENTIY LAST VALUE BASED ON THE NAME OF THE TABLE
SELECT IDENT_CURRENT('DBO.PRIMARYCONSTRAINT')


--WE CAN CREATE PRIMARRY WITH MULTIPLE COLUMN IN IT R&D
--FORIGEN KEY 
---IT WILL THROW AN CONFLICT ERROR WHICH SEEMS TO BE ITT HAS DATA WHICH NOT IN PARENT TABLE
--WITH NOCHECK WILL LET YOU TO ADD CONSTRAINT TO NEW DATAS WHILE INSERTING
ALTER TABLE TRANSAC
ADD CONSTRAINT DEFFORIGINKEY FOREIGN KEY (EMPLOYEENUMBER) 
REFERENCES DATAS (EMPLOYEENUMBER); 

--PROVE
SELECT TRANSAC.EMPLOYEENUMBER,DATAS.EmployeeNumber FROM TRANSAC
LEFT JOIN DATAS
ON TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber;

---PROVE
SELECT * FROM DATAS WHERE DATAS.EmployeeNumber = 109; 

--
ALTER TABLE TRANSAC WITH NOCHECK
ADD CONSTRAINT DEFFORIGINKEY FOREIGN KEY (EMPLOYEENUMBER) 
REFERENCES DATAS (EMPLOYEENUMBER); 

ALTER TABLE TRANSAC 
DROP CONSTRAINT DEFFORIGINKEY;


GO

BEGIN TRAN 

ALTER TABLE TRANSAC 
ADD CONSTRAINT DEFDEFAULTSET DEFAULT 20023 FOR EMPLOYEENUMBER;

--THIS WAY WE CAN UPDATE THE VALUE IN THE BOTH TABLE ---IMPORTATNT
--ALTER TABLE TRANSAC WITH NOCHECK
--ADD CONSTRAINT DEFFORIGINKEY FOREIGN KEY (EMPLOYEENUMBER) 
--REFERENCES DATAS (EMPLOYEENUMBER) ON UPDATE CASCADE; 

--INSTEAD SHOWING THE VOILATION ERROR WE CAN SET THE VALUE TO NULL WHEN USER UPDATE THE VALUE
--THIS IS NOT WORKING NEED TO R&D
ALTER TABLE TRANSAC WITH NOCHECK
ADD CONSTRAINT DEFFORIGINKEY FOREIGN KEY (EMPLOYEENUMBER) 
REFERENCES DATAS (EMPLOYEENUMBER) ON UPDATE SET DEFAULT; 

UPDATE DATAS
SET EMPLOYEENUMBER = 2123
WHERE EMPLOYEENUMBER = 658;


SELECT TRANSAC.EMPLOYEENUMBER,DATAS.EmployeeNumber FROM TRANSAC
LEFT JOIN DATAS
ON TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber
WHERE TRANSAC.EMPLOYEENUMBER = 2123;


ROLLBACK TRAN

GO

SELECT * FROM TRANSAC;

---BIG NOTE 
-- WE CANT MODIFY THE DATA IN THE PARENT TABLE BUTCAN BE MODIFIY IN CHILD TABLE 
--TO MODIFY IN THE PARENT KEY WE SHOULD ADD THE CASCADE ON UPADTE IN CHILD TABLE 


--WORKING WITH VIEWS
--TYPES OF VIEWS SIMPLE AND COMPLEX VIEWS 

---COMPLEX VIEWS 
---IN THIS EXAMPLE IF WE SHARE THE QUERY THE USER CAN ALTER THE VALUES OF BETWEEN 
--INSTEAD 123 TO 900 SO THEY CAN SEE OTHER EMPLOYEE RECORD 
-- TO PREVENT THAT WE CAN CREATE VIEWS IN AND SEND THE VIEW TO EMPLOYE SO THAT THEY CAN USE 
-- VIEW AND QUERY TO FETCH THE DETAILS WITH THE SUBSET OF TABLES
--SAME WISE THEY CAN SEE COLUMN BY ADD INTO THE QUERY THEN THEY SEE COLUMN AS WELL
--VIEWS PREVENT THAT ALSO
--VIEWS CREATED SHOULD BE WITHIN THE BATCH
GO
CREATE VIEW SORETEDVIEW AS
SELECT 
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,DATAS.DateOfBirth,DATASINTO.Department,TRANSAC.AMOUNT
FROM
DATAS
LEFT JOIN
DATASINTO
ON DATAS.Department = DATASINTO.Department
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 123 AND 135
GO

---VIEW CREATED 
---FETCH THE SPECIFIC RECORD
SELECT *  FROM SORETEDVIEW WHERE EmployeeFirstName = 'JANE';

--HOW TO ALTER VIEW AND HOW TO DROP VIEW
--VIEWS WON'T WORK FOR 
-- inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified.
GO
ALTER VIEW SORETEDVIEW  WITH ENCRYPTION
AS 
SELECT 
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,DATAS.DateOfBirth,DATASINTO.Department,TRANSAC.AMOUNT
FROM
DATAS
LEFT JOIN
DATASINTO
ON DATAS.Department = DATASINTO.Department
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 123 AND 135
--ORDER BY DATAS.EmployeeNumber DESC
GO


SELECT * FROM SORETEDVIEW;

---HOW TO CHECK WHETHER THE VIEW EXIST
--USING IF AND EXIST 

--THESE QUERY WILL LIST WHAT ARE THE VIEWS ARE THERE  
SELECT * FROM SYS.VIEWS  WHERE [NAME] = 'SORETEDVIEW';

SELECT * FROM INFORMATION_SCHEMA.VIEWS;
GO
--USING IN THE IF CONDITION
-- ADDING IF CONDITION TO CHECK IT WHETHER IT HAS VIEW OR NOT
-- EXSIT WILL RETURN TRUE WHEN IT RETURN ANY ROW IF NOT IT WILL RETURN FALSE
IF EXISTS(SELECT * FROM SYS.VIEWS WHERE [NAME] = 'SORETEDVIEW')
  PRINT('EXIST');
ELSE
  PRINT('NOT EXSIST')
GO
--THIS IS THE OPTIMUM WAY BUT I DON'T KNOW WHY
IF EXISTS(SELECT * FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'SORETEDVIEW' AND TABLE_SCHEMA = 'DBO')
  PRINT('EXIST');
ELSE
  PRINT('NOT EXSIST')

--IN SOME OTHER WAY WE CAN GET THE DEFINITION
--THESE WAY
SELECT I.TEXT FROM SYS.syscomments AS I 
INNER JOIN SYS.VIEWS AS O
ON I.id = O.object_id

SELECT * FROM SYS.sql_modules;

SELECT  OBJECT_DEFINITION(OBJECT_ID('DBO.SORETEDVIEW'));

--THESE ARE THE WAY WE CAN RETRIVE THE DEFINITION OF VIEWS

-- TO PREVENT THAT WE NEED WITH ENCRYPTION KEY WORD TO ENCRYPT THE DEFINTION


GO
ALTER VIEW SORETEDVIEW  WITH ENCRYPTION
AS 
SELECT 
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,DATAS.DateOfBirth,DATASINTO.Department,TRANSAC.AMOUNT
FROM
DATAS
LEFT JOIN
DATASINTO
ON DATAS.Department = DATASINTO.Department
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 123 AND 135
--ORDER BY DATAS.EmployeeNumber DESC
GO

--THEN IT WILL SHOW NULL
SELECT I.TEXT FROM SYS.syscomments AS I 
INNER JOIN SYS.VIEWS AS O
ON I.id = O.object_id

SELECT * FROM SYS.sql_modules;

SELECT  OBJECT_DEFINITION(OBJECT_ID('DBO.SORETEDVIEW'));

--UPDATING AND DELETE THE ROWS 
-- THIS ERROR WILL POPUP WHEN IT TRIES TO UPDATE MULTIPLE TABLE
--- View or function 'SORETEDVIEW' is not updatable because the modification affects multiple base tables.


--IMPORTANT NOTE 
--IN THIS COMPLEX VIEW THE TABLE HAS BEEN CREATED WITH THREE TABLES
--WHEN YOU UPDATE THE THREE TABLE OR TWO TABLE VALUE THROUGH A SINGLE 
---INSERT STATEMENT IT WON'T WORK
--BUT IN THIS TABLE WE HAVE TOTAL TRANSAC TABLE COLUMN 
--WHEN WE PROVIDE THOSE COLUMN AT THE TIME ONLY WE INSERT A DATA 
--IT WILL UPDATE OTHER COLUMN DYNAMICALLY
--EMPLOYEE AND GOVERMENT AND DEPARTMENT ID UPDATED ACCORDINGLY
SELECT * FROM SORETEDVIEWS;

SELECT * FROM TRANSAC;

GO

BEGIN TRAN

INSERT INTO SORETEDVIEWS(EmployeeNumber,DATEOFFTRANSACTION,AMOUNT) VALUES(123,'01/02/2020',999.99)

SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = 123; 

--SELECT 
--TRANSAC.EmployeeNumber,
--DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,TRANSAC.DATEOFFTRANSACTION,DATASINTO.Department,TRANSAC.AMOUNT
--FROM
--DATAS
--LEFT JOIN
--DATASINTO
--ON DATAS.Department = DATASINTO.Department
--LEFT JOIN
--TRANSAC
--ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
--WHERE DATAS.EmployeeNumber = 123

SELECT * FROM SORETEDVIEWS

ROLLBACK TRAN
GO
ALTER VIEW SORETEDVIEWS  WITH ENCRYPTION
AS 
SELECT 
TRANSAC.EmployeeNumber,
DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,TRANSAC.DATEOFFTRANSACTION,DATASINTO.Department,TRANSAC.AMOUNT
FROM
DATAS
LEFT JOIN
DATASINTO
ON DATAS.Department = DATASINTO.Department
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 123 AND 135
--ORDER BY DATAS.EmployeeNumber DESC
GO

SELECT * FROM SORETEDVIEW;

--THIS WON'T WORK BECAUSE WE ARE UPDATING MULTIPLE ROWS
GO
BEGIN TRAN

INSERT INTO SORETEDVIEWS(EmployeeGovernmentID,DATEOFFTRANSACTION,AMOUNT) VALUES('GHX12145H','01/02/2020',999.99)

SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = 123; 


SELECT 
TRANSAC.EmployeeNumber,
DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,TRANSAC.DATEOFFTRANSACTION,DATASINTO.Department,TRANSAC.AMOUNT
FROM
DATAS
LEFT JOIN
DATASINTO
ON DATAS.Department = DATASINTO.Department
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber = 123

ROLLBACK TRAN

GO




GO


ALTER VIEW SORETEDVIEWS  WITH ENCRYPTION
AS 
SELECT 
TRANSAC.EmployeeNumber,
DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,TRANSAC.DATEOFFTRANSACTION,DATASINTO.Department,TRANSAC.AMOUNT
FROM
DATAS
LEFT JOIN
DATASINTO
ON DATAS.Department = DATASINTO.Department
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 123 AND 135
--ORDER BY DATAS.EmployeeNumber DESC
GO

--- WITH CHECK OPTION WE CAN'T MODIFY THE DATA 
-- LIKE INSERT UPDATE AND DELETE THE DATA

GO

BEGIN TRAN 

--INSERT INTO SORETEDVIEWS(EmployeeNumber,DATEOFFTRANSACTION,AMOUNT) VALUES(123,'01/02/2020',999.99);

---WHAT IF WE UPDATE THE VALUE IN THE VIEW DOES IT UPDATE IN THE REPECTIVE TABLE 
--YES IT UPDATE IN THE REPECTIVE TABLE AND VIEW 
--IF WE UPDATE THE VALUE WHICH DOES'T FALLL IN THE CRITERIA LIKE IN BTEWEEN  123 TO 135
-- IF WERE UPDATE TO 142 THE DATA WILL BE MOVED OUT FROM THE TABLE.

UPDATE SORETEDVIEWS 
SET EMPLOYEENUMBER = 1778
WHERE EMPLOYEENUMBER = 123;

--SELECT * FROM SORETEDVIEWS;

--SELECT * FROM DATAS WHERE EMPLOYEENUMBER = 142;

--SELECT 
--TRANSAC.EmployeeNumber,
--DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,TRANSAC.DATEOFFTRANSACTION,DATASINTO.Department,TRANSAC.AMOUNT
--FROM
--DATAS
--LEFT JOIN
--DATASINTO
--ON DATAS.Department = DATASINTO.Department
--LEFT JOIN
--TRANSAC
--ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
--WHERE DATAS.EmployeeNumber BETWEEN 123 AND 135

ROLLBACK TRAN



GO


--TO PREVENT INSERT UPDATE AND DELETE HAS BEEN ALLOWED ONLY IF 
---SATISFY THE VIEW DEFINITION OR VIEW CRITERIA;

ALTER VIEW SORETEDVIEWS  WITH ENCRYPTION
AS 
SELECT 
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,TRANSAC.DATEOFFTRANSACTION,DATASINTO.Department,TRANSAC.AMOUNT
FROM
DATAS
LEFT JOIN
DATASINTO
ON DATAS.Department = DATASINTO.Department
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 123 AND 135
WITH CHECK OPTION
GO

--NOW EXCUTE THE ABOVE STATEMENT
--IT WILL THROW THIS ERROR
---The attempted insert or update failed because the target view either specifies 
--WITH CHECK OPTION or spans a view that specifies WITH CHECK OPTION and one or
 --more rows resulting from the operation did not qualify under the CHECK OPTION constraint.


 ---DELETE THE VIEW 
 -- IF VIEW MADE OF MULTIPLE TABLE WE CAN'T DELETE THE ROWS

 BEGIN TRAN

 DELETE FROM SORETEDVIEWS
 WHERE EmployeeNumber = 123;


 SELECT * FROM SORETEDVIEWS;


 ROLLBACK TRAN

 --IT JUST BECAUSE IT WILL UPDATE MULTIPLE TABLE


 ---BUT IF WE CREATED A VIEW WITH SINGLE TABLE IT IS POSSIBLE

 GO


CREATE VIEW SINGLETABLEVIEW AS
SELECT * FROM TRANSAC
GO


--WHEN WE DELETE THE ROW
--IT WILL WORK 
--MULTIPLE TABLE VIEWS CAN BE DELETED USING TRIGGERS
BEGIN TRAN 

DELETE FROM SINGLETABLEVIEW
WHERE EMPLOYEENUMBER = 123;

SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = 123;

ROLLBACK



----INDEX CAN BE CREATED ON THE VIEW


GO
ALTER VIEW SORETEDVIEWS  WITH SCHEMABINDING
AS 
SELECT 
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,DATAS.EmployeeGovernmentID,TRANSAC.DATEOFFTRANSACTION,DATASINTO.Department,TRANSAC.AMOUNT
FROM
DBO.DATAS
INNER JOIN
DBO.DATASINTO
ON DATAS.Department = DATASINTO.Department
INNER JOIN
DBO.TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 123 AND 135
WITH CHECK OPTION
GO


-- IT WILL SHOW NOT SCHEMA BOUNDING ERROR WITH MEANS 
-- WE SHOULD CREATE OUR INDEX WITH SCHEMA BOUNDS
-- ADD SCHEMABINDINGS KEYWORD BEFORE AS 
-- THEN REOMVE LEFT JOIN TO INNER JOIN
---IF NOT WILL THROW THIS ERROR
--Cannot create index on view "70-461.dbo.SORETEDVIEWS" because it uses a LEFT, RIGHT,
 --or FULL OUTER join, and no OUTER joins are allowed in
 --indexed views. Consider using an INNER join instead.


 --SUCCESFULLY CREATED INDEX
CREATE UNIQUE CLUSTERED INDEX IX_UNIQUECLUSTEREDINDEXINSORTEDVIEWS ON SORETEDVIEWS (EmployeeNumber,DATEOFFTRANSACTION)



--REPRACTICES VIEW 
BEGIN TRAN
CREATE TABLE PROFILE(
ID INT PRIMARY KEY IDENTITY(1,1),
NAME NVARCHAR(50),
MOBILE BIGINT
)

CREATE TABLE PROJECTDETAILS
(
PROJECTID INT PRIMARY KEY IDENTITY(1,1),
PROJECTNAME VARCHAR(75),
CLINET VARCHAR(25)
)

DROP TABLE PROJECTDETAILS;

CREATE TABLE EMPLOYEEDETAILS
(
  EMPLOYEEID INT IDENTITY(100,1),
  ID INT REFERENCES PROFILE(ID),
  ROLE VARCHAR(55),
  SALARY DECIMAL(15,3),
  PROJECTID INT REFERENCES PROJECTDETAILS(PROJECTID)
)
ROLLBACK TRAN



GO
BEGIN TRAN
---ALLTER THE VIEW TO PROVE THAT
--INSERT HAS BEEN WORKING FOR VIEWS AND TABLE 
--IF VIEW DOEST HAVE ANY WHERE CAULSE OR FILTERS
GO
ALTER VIEW PROFILEVIEW
AS
SELECT
*
FROM 
PROFILE
GO
--IN THE ABOVE EXAMPLE I HAVE BEEN CREATING THE VIEW FOR JUST ONE ROW
--THEN I TRY TO UPDATE OTHER ROWS IN THAT VIEW BUT THOSE ARE NOT THERE
--THOSE ARE IN ORGINAL TABLE

--ONE  ROW VIEWS
--SELECT * FROM PROFILEVIEW

INSERT INTO PROFILEVIEW(NAME,MOBILE)  VALUES ('KISHORE',9874561235);

--UPDATE DON'T WORK
--DELETE WON'T WORK
UPDATE PROFILEVIEW
SET MOBILE = 000000000
WHERE ID = 5;

DELETE FROM 
PROFILEVIEW
WHERE ID =3;

--UPDATING THE EXISITING VALUE
UPDATE PROFILEVIEW
SET MOBILE = 9942711513
WHERE ID = 2;

--DELETE FROM PROFILE
--WHERE ID = 1002;


SELECT * FROM PROFILEVIEW;

SELECT * FROM PROFILE;
GO
ROLLBACK TRAN
GO

--PLAYING WITH COMPLEX VIEWS
BEGIN TRAN
GO
CREATE VIEW COMPLEXPROFILE
AS
SELECT 
PROFILE.[ID],
[NAME],
[MOBILE],
[ROLE],
PROJECTDETAILS.[PROJECTID],
PROJECTDETAILS.[PROJECTNAME],
[CLINET],
[SALARY]
FROM
PROFILE INNER 
JOIN EMPLOYEEDETAILS ON PROFILE.ID = EMPLOYEEDETAILS.ID  
LEFT JOIN PROJECTDETAILS ON EMPLOYEEDETAILS.PROJECTID = PROJECTDETAILS.PROJECTID;
GO

SELECT * FROM COMPLEXPROFILE

--ALTER TABLE [dbo].[PROJECTDETAILS]
--DROP CONSTRAINT [PROJECTID];


--THE ABOVE VIEW WE HAVE THREE TABLE
--PROFILE AND PROJECTS DETAILS TABLE HAS THE ENTIRE COLUMN

--SO I GONNA UPDATE THE ONE VALUE IN PROJECT DETAILS TABLE THROUGH VIEWS
--INSERT INTO  COMPLEXPROFILE([PROJECTNAME],CLINET,SALARY)
--VALUES ('YMAHA','RUSSIA');

--HERE JUSTIFYING THAT VIEW DOES NOT GET 
--INSERTED BECAUSE IT NEEDS TO UPDATE ALL THE COLUMNS IN VIEW 
--I GUESS IF WE INSERT IT WILL NOT INSERT ON THE SOURCE TABLE AS WELL

--UPDATE CERTAIN COLUMN
UPDATE  COMPLEXPROFILE
SET PROJECTNAME ='GPAY'
WHERE PROJECTID = 4;

SELECT * FROM COMPLEXPROFILE;

--DELETE
--DELETE NEEDS TO DELTE FROM THE ALL THE THREE TABLE THAT'S WHY IT 
--WON'T WORK
--DELETE FROM COMPLEXPROFILE
--WHERE ID = 5;

--TRY TO UPDATE THE ROLE
--IT JUST UPDATING THE EMPLOYEEDETAILS AND COMPLEXPROFILE
--UPDATE COMPLEXPROFILE
--SET ROLE = 'CFO'
--WHERE ID = 2;

DELETE FROM COMPLEXPROFILE
WHERE ROLE = 'BA';

SELECT * FROM COMPLEXPROFILE

SELECT * FROM EMPLOYEEDETAILS;



ROLLBACK TRAN







---TRIGGERS
-[ROLE]-AFTER TRIGER WILL WORK AFTER THE INSERT,UPDATE,DELETE
--INSTEAD OF - BEFORE INSERT, UPDATE AND DELETE

---CREATE TRIGGERS

GO
CREATE TRIGGER TRIG_TRANSACTRIGGER
ON TRANSAC
AFTER INSERT,UPDATE,DELETE
AS
BEGIN
---THIS WILL NOT SHOW HOW MANY ROW AFFECTEED
---TRUNING ON
SET NOCOUNT ON
SELECT * FROM inserted;
SELECT * FROM deleted;
SET NOCOUNT OFF  
END
GO

--TRIGGER WILL WORK WHENEVER WE INSERT,UPDATE THE TABLE 
--IT WILL SHOW ONLY NEW VALUES IT WILL NOT SHOW ANY OLD VALUES
--BECAUSE IT WILL BEFOR INSERTING THERE IS NO VALUES , WE ARE NOT UPDATING HERE
INSERT INTO TRANSAC VALUES(12.56,GETDATE(),123);



--BY TURNIG ON WILL NOT HOW MANY ROW AFFECTED
--BY TURNING IT WILL SHOW AFFECTED 
SET NOCOUNT  ON 
SET NOCOUNT OFF
SELECT * FROM TRANSAC;


--WITH TRIGGERS WE CAN DELETE THE VIEW ROW HOW COME
--WHILE DELETE THE VIEW WE CAN CREATE TRIGGERS TO DELETE THE ORGINAL TABLE VALUE 
--SO IT WILL DELETE THE VIEWS ROW INDIRECTLY

--NEEED TO DO R&D  WITH NO CHECK OPTION TRIGGERS 
--WON'T WORK


GO
CREATE TRIGGER TRIG_SORTEDVIEWS
ON [dbo].[ViewByDepartment]
INSTEAD OF DELETE
AS
BEGIN
SET NOCOUNT ON
SELECT * FROM TRANSAC;
SET NOCOUNT OFF
END
GO

DROP TRIGGER TRIG_SORTEDVIEWS;

--CREATING NEW VIEW
GO
CREATE view [dbo].[ViewByDepartment] as 
select D.Department, T.EmployeeNumber, T.DATEOFFTRANSACTION, T.Amount as TotalAmount
from DATASINTO as D
left join DATAS as E
on D.Department = E.Department
left join TRANSAC as T
on E.EmployeeNumber = T.EmployeeNumber
where T.EmployeeNumber between 120 and 139;
GO

--TRY TO DELETE THE RECORD IN DEP VIEW
--WITHOUT TRIGER




BEGIN TRAN

--SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = 123 AND  AMOUNT = 12.56;

--WITHOUT TRIGGER IT WILL SHOW MULTIPLICATION  UPDATES ERROR
--AFTER TRIGGER
--- IT WILL NOT SHOW ANY ERROR MESSAGE INSTEAD IT WILL EXCUTE THE TRIGGERS CODES
---WILL SEE TRANSAC TABLES
--BY SO WE CAN DELETE THE VALUES IN MULTIPLE TALES
--
DELETE FROM ViewByDepartment
 WHERE EMPLOYEENUMBER = 123 AND  TotalAmount = 12.56;


--FRO JUSTIFICATION

SELECT 1;

SELECT * FROM ViewByDepartment  WHERE EMPLOYEENUMBER = 123 AND  TotalAmount = 12.56;



ROLLBACK TRAN

--TRIGGERS
GO
ALTER TRIGGER TRIG_SORTEDVIEWS
ON [dbo].[ViewByDepartment]
INSTEAD OF DELETE
AS
BEGIN
SET NOCOUNT ON

DECLARE @EMPLYEENUMBER AS INT
DECLARE @AMOUNT AS SMALLMONEY
DECLARE @DATEOFTRANSACTION SMALLDATETIME

--THIS ANOTHER WAY OF ASSIGNING VALUE SP IMPORTATNT
SELECT @EMPLYEENUMBER = EmployeeNumber , @AMOUNT = TotalAmount ,@DATEOFTRANSACTION = DATEOFFTRANSACTION FROM deleted

SELECT * FROM inserted;
SELECT * FROM deleted;

--IF TRANSAC HAS TRIGGERS IT WILL CREATE ANOTHER TRIGGERS
DELETE FROM TRANSAC WHERE EMPLOYEENUMBER = @EMPLYEENUMBER AND  AMOUNT = @AMOUNT;

SET NOCOUNT OFF
END
GO

----NESTED TRIGGERS ISSUE
ALTER TRIGGER TRGI_IN_TRANSAC
ON TRANSAC
AFTER INSERT,DELETE,UPDATE
AS
BEGIN
--SELECT @@NESTLEVEL AS NESTEDTRIGGERCOUNT;
--WE CAN NEST THIS OUT AND CAN DO CONDITION CHECK

IF(@@NESTLEVEL = 1)
BEGIN
SELECT @@NESTLEVEL NESTEDCOUNT; 
SELECT * FROM inserted;
SELECT * FROM deleted;
END
END

---NESTLEVEL WILL SHOW YOU RESULT LIKE 1 IN THIS CASE
--IT JUST BECAUSE ONLY ONE TRIGGER EXCUTED IN THE BACKROUND
--MAXIMUM LEVEL @@NESTLEVEL WILL BE 32

BEGIN TRAN
INSERT INTO TRANSAC(EMPLOYEENUMBER,DATEOFFTRANSACTION,AMOUNT) VALUES(1234,GETDATE(),200.36);
ROLLBACK TRAN


----WHEREAS IF WE INSERT INTO VIEW IT WILL SHOW TWO IT JUST BECAUSE
--IT HAS TWO TRIGGERS INSIDE IT ONE INSIDE VIEW AND ANOTHER ONE INSIDE TRANSAC TABLE
--BUT AFTER ADDING IF CONDITION WE CAN'T CREATE THAT


BEGIN TRAN
DELETE FROM ViewByDepartment WHERE TotalAmount = -2.77 AND EmployeeNumber=132;
ROLLBACK TRAN

SELECT * FROM ViewByDepartment;

---NESTED TRIGGERS CONFIGURATION

---THIS WILL GIVE YOU SET VALUE
EXEC sp_configure 'NESTED TRIGGERS'

---IF WE CHANGE THE VALE CONFIG_VALUE 1 TO 0
---WE CAN PREVENT AFTER TRIGGER RECUSIVENES BUT NESTED TRIGGER WILL WORK
BEGIN TRAN
EXEC sp_configure 'NESTED TRIGGERS',1;
ROLLBACK TRAN


---WHEN EVER WE EXECUTE THE TRANSAC TABLE DELETE STATEMENT
---EVEN THOUGH WE DELETED THE TABLE VALUE AND AGAIN WE RN IT WE WON'T
--GET ANY ERROR BECAUSE TRIGGER CODE WILL RUN


GO
ALTER TRIGGER TRGI_IN_TRANSAC
ON TRANSAC
AFTER INSERT,DELETE,UPDATE
AS
BEGIN
	
		---@@ROWCOUNT GLOBAL VARIABLE WILL RETURN HOW MANY ROW AFFECTED
		--NOT WORKING @@ROWCOUNT INDENTTATION ARE VERY IMPORTANT TO WORK
		----UPDATE(TotalAmount)
		---UPDATE FUNCTION WILL WORK WHEN THER IS UPDATE QUERY RUNS
		--WHEN THE USER UPDATE THE SAM VALUE AT THE TIME ALSO IT WILL WORK
		--IF THEY UPDATED THE VALUE AS SAME VALUE BEFRE YOU CAN COMPARE THE THINGS USING
		--INSERTED.COLUMN - DELETED.COLUMNNAME IN IF CONDITION
		--IF(@@ROWCOUNT = 0)
		--COLUMN_UPDATED() & 2 = 2
		--THIS WILLL ALSO CHECK LIKE THAT BUT IT CAN GIVEN UPTO ONLY NINE 
		--IT READ ONLY NINE COLUMN  ; 1 FOR FIRST COLUMN LIKE WISE IT WILL WORK
		IF(UPDATE(AMOUNT))
		BEGIN
			SELECT @@ROWCOUNT;
			PRINT(@@ROWCOUNT);
			SELECT * FROM inserted;
			SELECT * FROM deleted;
		END
END
GO
BEGIN TRAN
INSERT INTO TRANSAC(EMPLOYEENUMBER,DATEOFFTRANSACTION,AMOUNT) VALUES(1234,GETDATE(),200.36);
INSERT INTO TRANSAC(EMPLOYEENUMBER,DATEOFFTRANSACTION,AMOUNT) VALUES(1234,GETDATE(),200.36);
ROLLBACK TRAN

BEGIN TRAN 
UPDATE TRANSAC
SET TRANSAC.AMOUNT = 2.770
WHERE EMPLOYEENUMBER = 132 AND TRANSAC.AMOUNT = -2.77
ROLLBACK TRAN

SELECT * FROM TRANSAC WHERE AMOUNT = -2.77;





---UNION IT IS USED TO JOIN THE RESULT SET IN TERMS OF ROWS
--CRITERIA
--BOTH SHOULD HAVE SAME NUMBEROF COLUMNS
--BOTH SHOULD HAVE SAME NUMBER DATATYPE
-- DATA TYPE WILL WORK IN THE PRECEDENCE 
--CHAR(5) AND CHAR(10) CHAR(10) WILL WORK AND IT WILL BE CONSIDERED AS A RESULTDATATYPE
--BUT IF CHAR(10) AND INT IT WILL THROW ERROR
GO
SELECT CONVERT(CHAR(5),'HI')
UNION
SELECT CONVERT(CHAR(11),'HI AJAY');

--FIRST COLUMN NAME WILL BE CONSIDERED
SELECT CONVERT(CHAR(5),'HI') AS NAMES
UNION
SELECT CONVERT(CHAR(5),'HI AJAY') AS FULLAMES;


---UNON WONT WORK IN THE SORTED ORDER
---FOR PROVE THAT BELOW CODE
--THIS PROVES IT WONT DORT BECAUSE HA SHOULD COME FIRST
SELECT CONVERT(CHAR(5),'HI') AS NAMES
UNION
SELECT CONVERT(CHAR(5),'HA AJAY') AS FULLAMES;


---BUT SOME HOW IT SORTS NOT COMPLETELY
SELECT CONVERT(CHAR(5),'HI') AS NAMES
UNION
SELECT CONVERT(CHAR(5),'HA AJAY') AS FULLAMES
UNION
SELECT CONVERT(CHAR(5),'AJAY') AS FULLAMES;


--IT WON'T ALLLOW NAY DULICATES
SELECT CONVERT(CHAR(5),'HI') AS NAMES
UNION
SELECT CONVERT(CHAR(5),'HA AJAY') AS FULLAMES
UNION
SELECT CONVERT(CHAR(5),'AJAY') AS FULLAMES
UNION
SELECT CONVERT(CHAR(5),'AJAY') AS FULLAMES;

---TO PRESERRVE A DUPLICATES WE NEED TO USE UNION ALL
SELECT CONVERT(CHAR(5),'HI') AS NAMES
UNION ALL
SELECT CONVERT(CHAR(5),'HA AJAY') AS FULLAMES
UNION ALL
SELECT CONVERT(CHAR(5),'AJAY') AS FULLAMES
UNION ALL
SELECT CONVERT(CHAR(5),'AJAY') AS FULLAMES;


WITH CTE AS(
SELECT CONVERT(smallint,12) AS COLUMNSE
UNION
SELECT CONVERT(bigint,120)
)
SELECT COLUMNSE
INTO NEWTABLE
FROM CTE;

--TO PROVE THAT IT HAS TAKEN THE BIGDATA TPE SEE THE SOLUTION EXPLORE


SELECT 'AJAY'
UNION
SELECT 45;

---WONT WORK BECAUSE OF PRECEDENCE

--EXCEPT CONCEPT

CREATE TABLE EXCEPT_TABLE_ONE
( 
SNO INT
);

INSERT INTO EXCEPT_TABLE_ONE VALUES(1),(2),(3),(5),(6)

CREATE TABLE EXCEPT_TABLE_TWO
( 
SNO2 INT
);

INSERT INTO EXCEPT_TABLE_TWO VALUES(1),(2),(3),(4),(7);

---EXCEPT WORK LIKE
-- ONE TABLE 1,2,3,5,6
--IT WILL TAKE ALL THE FIVE VALUES AND COMPARE WITH TABLE TWO
-- TWO HAS 1,2,4,7
--IT WILL DROP THE VALUE WHICH IS COMMON TWO BOTH TABLES LIKE 1,2,3
---AND PRESENT REST OF THE VALUES IN TABLE ONE(5,6) AND WONT INCULDE 4,7 
---IMPORTANT BECAUSE WE DO EXCEPT FROM ONE TWO SO THATY WHY UNIQUE VALUES IN THE SECOND TABLE
--WON'T CONSIDERED
GO
SELECT * FROM EXCEPT_TABLE_ONE
EXCEPT
SELECT * FROM EXCEPT_TABLE_TWO;
GO
--NOW 4,7
-- WILL BE OUTPUT
SELECT * FROM EXCEPT_TABLE_TWO
EXCEPT
SELECT * FROM EXCEPT_TABLE_ONE;

---INTERSEPT WILL RETURN ONLY THE COMMON RESULT
--1,2,3
SELECT * FROM EXCEPT_TABLE_ONE
INTERSECT
SELECT * FROM EXCEPT_TABLE_TWO;

--SUMMARY  --IMPORTANT
--UNION WILL GIVE YOU THE VALUE FROM THE BOTH TABLE EXCEPT DUPLICATES 
--UNION ALL WILL GIVE ALL THE VALUES INCLUDE DUPLICATES
--INTERSEPT WILL GIVE YOU ONLY THE COMMON VALUES
--EXCEPT WILL GIVES THE UNCOMMON VALUES FROM THE FIRST TABLE

---CASE STATEMENT 
GO
DECLARE @NAME AS VARCHAR(20);

SET @NAME = 'GUEST';


SELECT  CASE WHEN @NAME = 'USER' THEN 'USER LOGED IN'
            WHEN @NAME = 'GUEST' THEN 'GUEST LOGGED IN'
			ELSE 'ADMINLOGGED IN' END AS USERNAME;
---CASE STATEMENT IS MORE IMPORTANT
---ELSE IS OPTIONAL 
---IF ELSE IS NPT THERE BUT THE CONDITION ARE NOT SATISFIED
---IT WILL RESULT AS NULL BELOW EXAMLE

GO

DECLARE @NAME AS VARCHAR(20);

SET @NAME = 'NOT';

SELECT CASE WHEN @NAME = 'USER' THEN 'USER LOGED IN'
            WHEN @NAME = 'GUEST' THEN 'GUEST LOGGED IN'
			END AS USERNAME;

GO

---WE CAN'T HAVE MULTIPLE DATA TYPE IN CASE STATEMENT

GO

DECLARE @NAME AS VARCHAR(20);

SET @NAME = 'USER';

SELECT  CASE WHEN @NAME = 'USER' THEN 'USER LOGED IN'
            WHEN @NAME = 'GUEST' THEN 100.23
			END AS USERNAME;

GO

---ABOVE EXAMPLE WILL THROW AN EROR BECAUSE 
---IT HAS BEEN SHOWING THAT NUMERIC TO STRING TO POSSIBLE TO CONVERT
--IN OVERALL STATEMENT BIGGEST DATA TYPE WILL BE THE NUMERIC SO WHEN IT TRY TO CONVERT INTO 
--VARCHAR() IT COULD NOT BECAUSE PRECEDENCE

GO

DECLARE @NAME AS VARCHAR(20);

SET @NAME = 'GUEST';

SELECT  CASE WHEN @NAME = 'USER' THEN 'USER LOGED IN'
            WHEN @NAME = 'GUEST' THEN 100.23
			END AS USERNAME;

GO

---BUT IN THIS CASE IT WON'T SHOW THAT ERROR 
--IT JUST BECAUSE OF SELECTING THE BIG DATA TYPE NUMERIC 100.23
--  IF IT CONVERTS TO VARCHAR() OR INT IT WILL THROW ERROR BECAUSE PRECEDENT ISSUE


----NULL HANDLING 
----ISNULL METHODS IDENTIFED AS NULL IT WILL PRINT THE SECOND PARAMETER IN THE LIST
----IF NOT IT WILL  PRINT THE VARIABLE VALUE

GO

DECLARE @NAME AS VARCHAR(20);

--SET @NAME = 'USER';

SELECT  ISNULL(@NAME,'NULL IDENTIFIED');

GO
--ISNULL IS PRECEDENT INDEPENDET 
--COMPARE WITH INT VARCAHR()
GO

DECLARE @NAME AS VARCHAR(20);

SET @NAME = 'USER';

SELECT  ISNULL(@NAME,2);

GO

--WHERE AS COALASCE HAS PRECDENT ISSUE
--INT OT VARCHAR
--COALSCE
GO

DECLARE @NAME AS VARCHAR(20);

SET @NAME = 'USER';

SELECT  COALESCE(@NAME,2);

GO

GO

DECLARE @NAME AS VARCHAR(20);

DECLARE @DEPARTMENT AS VARCHAR(20);

--SET @NAME = 'USER';
--COALSECE WILL HAVE N NUMBER OF PARAMETER
--BUT IF ANY ONE HAS ANY VALUE THEN IT WIL SELECT THAT VALUES AS ANSWER 
--IF EVERY THING AS ERROR IT WILL PRINT AS NUL
SELECT  COALESCE(@NAME,@DEPARTMENT,'NULL IDENTIFIED');

GO

----COALESECE RETURN CONSTARINT IS NULL 
---WHERE AS IS NULL RETURN CONSTRAINT IS NOT NULL

---HOW TO CHECK THE RETURN DATA USING INTO TO CREATE A TABLE

GO
---WHERE AS IS NULL RETURN CONSTRAINT IS NOT NULL
DECLARE @NAME AS VARCHAR(20);

--SET @NAME = 'USER';

SELECT  ISNULL(@NAME,'NULL IDENTIFIED') AS COLUMNISNULLMETHOD
INTO TABLNULL1;

GO


GO
----COALESECE RETURN CONSTARINT IS NULL 

DECLARE @NAME AS VARCHAR(20);

--SET @NAME = 'USER';

SELECT  COALESCE(@NAME,'NULL IDENTIFIED') AS COLUMNISNULLMETHOD
INTO TABLCOALESCE;

GO

SELECT COALESCE(NULL,NULL) -- IS NOT POSSIBLE
SELECT ISNULL(NULL,NULL) --- IS POSSIBLE

---NULL AND COALESCE ARE IMPORTANT ISNULL IS MSSQL OTHER LANGUAGE COALESCE BECAUSE IT ACCEPTS MULTIPLE ARGUMENTS


--MEREGE STATEMENT IS USED TO UPDATE OR DELETE OR INSERT INTO A TARGET TABLE 
--BASED ON A CONDITION OR MATHCED VALUES IN A BOTH TABLES


                                                     --INSERT UPDATE AND DELLTE (TARGET TABLE ONLY)
 ---WITH MATCHED VALUES                                        1         1
 ---WITH MATHCED AND SOMTHING
 ---WITHOUT MATCHED IN TARGET                           1
 ---WITHOUT MATCHED IN TARSOURCEET AND CONDITION
 ---WITHOUT MATCHED IN SOURCE AND                              1          1

 CREATE TABLE STOCKS
 (
 PRODUCTNAME VARCHAR(20),
 STOCKSCOUNTS INT,
 );

 INSERT INTO STOCKS VALUES('SOAP',90),('DRY SHAMPOO',100) , ('SUNSCREEN',119),('SPORTS SUN SCREEN',50);

 
 CREATE TABLE SOLDCOUNT
 (
 PRODUCTNAME VARCHAR(20),
 SOLDCOUNT INT,
 );

 INSERT INTO SOLDCOUNT VALUES('SOAP',10),('DRY SHAMPOO',19) , ('SUNSCREEN',21) , ('HIMALAYA',25);



 ---USING MEREG
 SELECT * FROM STOCKS;
 SELECT * FROM SOLDCOUNT; 
INSERT INTO STOCKS VALUES('MOUTHWASH',150);

 BEGIN TRAN
 MERGE INTO STOCKS
 USING SOLDCOUNT
 ON STOCKS.PRODUCTNAME = SOLDCOUNT.PRODUCTNAME
 WHEN MATCHED THEN
         UPDATE SET STOCKS.STOCKSCOUNTS = STOCKS.STOCKSCOUNTS - SOLDCOUNT.SOLDCOUNT
 WHEN NOT MATCHED BY TARGET THEN
         INSERT (PRODUCTNAME,STOCKSCOUNTS)
		 VALUES  (PRODUCTNAME,SOLDCOUNT)
WHEN NOT MATCHED BY SOURCE THEN 
          DELETE;

SELECT * FROM STOCKS;
ROLLBACK TRAN;

---MEREG PRIMARLY UPDATES ONLY THE TARGET TABLE
--SOURCE TABLE WON'T GET ANY CHANGE IT JUST FOR COMPARISION 

--HERE I AM GOONA ADD THE COLUMN VALUE
--TARGET TABLE HERE STOCKS FORM THE SOURCE TABLE SOLDCOUNT
GO
BEGIN TRAN 
--ALTER TABLE STOCKS
--ADD COMMENTS VARCHAR(25);
MERGE STOCKS AS S
USING (SELECT TOP 100 PERCENT * FROM SOLDCOUNT) AS SC
ON S.PRODUCTNAME = SC.PRODUCTNAME
WHEN MATCHED AND S.STOCKSCOUNTS > 0 THEN
---WE CAN END BY MATCHED IT SELF
	UPDATE SET STOCKSCOUNTS = S.STOCKSCOUNTS + SC.SOLDCOUNT,S.COMMENTS = 'ADDED THE SUM'
WHEN MATCHED THEN
	DELETE
WHEN NOT MATCHED BY TARGET THEN
	INSERT (PRODUCTNAME,STOCKSCOUNTS,COMMENTS)
	VALUES(SC.PRODUCTNAME,SC.SOLDCOUNT,'INSERTED')
WHEN NOT MATCHED BY SOURCE THEN
	UPDATE SET S.COMMENTS = 'NOT MATCHED BY THE SOURCE';
SELECT *FROM STOCKS;
ROLLBACK TRAN
GO

---TWO UPDATE CAN BE USED FOR SMAE MATCHING CONDITION
--THOUGH TWO UPDATES SYNTACTICALLY CORRECT 
--IT CAN'T BE USED HERE
GO
BEGIN TRAN 
--ALTER TABLE STOCKS
--ADD COMMENTS VARCHAR(25);
MERGE STOCKS AS S
USING (SELECT TOP 100 PERCENT * FROM SOLDCOUNT) AS SC
ON S.PRODUCTNAME = SC.PRODUCTNAME
WHEN MATCHED AND S.STOCKSCOUNTS > 0 THEN
---WE CAN END BY MATCHED IT SELF
	UPDATE SET STOCKSCOUNTS = S.STOCKSCOUNTS + SC.SOLDCOUNT,S.COMMENTS = 'ADDED THE SUM'
WHEN MATCHED THEN
	UPDATE SET STOCKSCOUNTS = S.STOCKSCOUNTS + SC.SOLDCOUNT,S.COMMENTS = 'ADDED THE SUM'
WHEN NOT MATCHED BY TARGET THEN
	INSERT (PRODUCTNAME,STOCKSCOUNTS,COMMENTS)
	VALUES(SC.PRODUCTNAME,SC.SOLDCOUNT,'INSERTED')
WHEN NOT MATCHED BY SOURCE THEN
	UPDATE SET S.COMMENTS = 'NOT MATCHED BY THE SOURCE';
SELECT *FROM STOCKS;
ROLLBACK TRAN
GO


--ALTER TABLE STOCKS
--DROP COLUMN COMMENTS;

 SELECT * FROM STOCKS;
 SELECT * FROM SOLDCOUNT; 










---STORE PROCEDURE 
---TO CREATE STORE PROCEDURE FOR DAL
--WHY SO?
--IT JUST BECAUSE OF DON'T LET THE DEVELOPER TO ACCES THE TABLE COLUMN DIRECTLY
--WHICH MIGHT GIVES THE ACCES TO DELETE AND UPDATE THE DATA
--ANOTHER IMPORTATNT THING IS THAT 
--WHEN COLUMN NAME OF TABLE CHANGE AT THE SAME TIME IT SHOULD CHANGE IN THE C# ALSO
--BUT IF WE CREATE STORE PROC WE CAN SET THE ALIAS SO THE ALIAS NAME WILL BE PERMENETLY
--SOTRED IN STORE PROC WHENEVER CHANGE IN THE COLUMN NAME WE SHOULD CHANGE THAT INTO ONLY IN THE
--STORE PROC

GO
CREATE PROC FIRSTSOTOREPROC AS
BEGIN
SELECT * FROM TRANSAC;
END
GO

EXEC FIRSTSOTOREPROC;

---TO DROP THE STORED PROCEDURE 
DROP PROCEDURE FIRSTSOTOREPROC;

--TO CHECK THE STORED PROCEDURE 

IF EXISTS(SELECT * FROM SYS.procedures WHERE name = 'FIRSTSOTOREPROC')
SELECT 1;
SELECT OBJECT_ID('FIRSTSOTOREPROC');


---ARGUMENTS IS THAT THE THING WHICH IS YOU SUPPLIED
---PARAMETER IS THE THING WHICH IS FUCNTION HAS

--THIS HOW WE CAN ALTER THE STORE PROC AND GIVE THE PARAMETER
GO
ALTER PROC FIRSTSOTOREPROC(@EMPLOYENUMBER INT) AS
BEGIN
SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = @EMPLOYENUMBER ;
END
GO


EXEC FIRSTSOTOREPROC 123;

---CREATE THE NEW PROCEDURE FOR EMPLOYEE
GO
ALTER PROCEDURE EXERCISE(@EMPLOYEENUMBER INT)
AS
BEGIN
    IF(@EMPLOYEENUMBER IS NOT NULL)
	BEGIN
	    IF(@EMPLOYEENUMBER < 300)
		BEGIN
			SELECT EmployeeNumber,EmployeeFirstName,EmployeeLastName,Department FROM DATAS 
			WHERE EmployeeNumber = @EMPLOYEENUMBER;
		END
		ELSE
		BEGIN
			IF EXISTS(SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = @EMPLOYEENUMBER)
			BEGIN
				SELECT 
				DATAS.EmployeeNumber,EmployeeFirstName,EmployeeLastName,Department,
				TRANSAC.AMOUNT,TRANSAC.DATEOFFTRANSACTION
				FROM 
				DATAS LEFT JOIN  TRANSAC
				ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
				WHERE TRANSAC.EMPLOYEENUMBER = @EMPLOYEENUMBER;
			END
			ELSE
			SELECT 'EMPLOYEE NOT MADE ANY TRANSACTION IN HIS LIFE'
		END
    END
	ELSE
	   SELECT 'DATA IS NULL';
END	    
GO

EXERCISE 324;

--TO JUSTIFY THAT 
--SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = 324;

----TYPES OF PASSING THE ARGUMENTS 
GO
CREATE PROCEDURE EMPLOYERANGE (@EMPLOYEEFROM INT,@EMPLOYETO INT)
AS
BEGIN
   IF EXISTS(SELECT * FROM DATAS WHERE EmployeeNumber BETWEEN @EMPLOYEEFROM AND @EMPLOYETO)  
   BEGIN
		SELECT * FROM DATAS WHERE EmployeeNumber BETWEEN @EMPLOYEEFROM AND @EMPLOYETO
   END
   ELSE
       SELECT 'NOT EXISTS';
END
GO

---TYPE OF GIVING PARAMETER

EXEC EMPLOYERANGE 123 , 125;

---WE CAN GIVE USING VARIABLE NAME
--DIFFERENT ORDER 
EXEC EMPLOYERANGE @EMPLOYETO = 300 , @EMPLOYEEFROM = 120;

---SAME ORDER BOTH GIVE SAME RESULT
EXEC EMPLOYERANGE @EMPLOYEEFROM = 120 , @EMPLOYETO = 300 ;

--TO JUSTIFY
--SELECT * FROM DATAS WHERE EmployeeNumber BETWEEN 120 AND 300;


---TO USE WHILE LOOP IN SP
GO
ALTER PROCEDURE WHILELOOP(@START INT,@END INT) AS
BEGIN 
	IF(@START IS NOT NULL AND @END IS NOT NULL)
		BEGIN
			WHILE(@START < @END)
				BEGIN
					IF(@START = 5)
					BEGIN
					    SET @START = @START + 1;
						CONTINUE;
					END
					SELECT @START AS COUNTL;
					SET @START = @START + 1;
					IF(@START > 20)
					BEGIN
						BREAK
					END
					--NEED TO R&D ABOUT THE GOTO BUT NOT RCOMMENDED
					--IFI WERE USING GOTO IT WILL BREAK OUT FROMTHE LOOPS
					--IF(@START = 10)
					--BEGIN
					--	GOTO STATEMENTS1
					--	SET @START = @START + 1; 
					--	CONTINUE
					--END
				END
		END
END
STATEMENTS1:SELECT 'LINE 10 GOTO WORKS';
GO

WHILELOOP 1,25;

---SETTING RETURN STATEMENT SP
GO
ALTER PROCEDURE RETURNSTATEMENTPROCEDURE(@INPUT INT,@OUTPUT INT,@RESULT INT OUTPUT)
AS
BEGIN
	IF(@INPUT IS NOT NULL AND @OUTPUT IS NOT NULL)
		BEGIN
		    SELECT 'RESULT SUMATION' 
			SET @RESULT = @INPUT + @OUTPUT;
			RETURN 0;
		END
	ELSE
		BEGIN
		  SELECT 'INVALID INUPUT'
		  RETURN 1;
		END
END
GO
--RETURN 0 DEFINES THE SUCCES AND RETURN 1 DEFINES THE FAILURE;
--SET STATEMENT USED TO SET VALUE FOR RETURN PARAMETER
--OUTPUT DENTOES THIS VARIABLE WILL RETURN THE VALUE
--WE CAN RETURN THE VALUE NAD TABLE AT THE MEAN TIME

DECLARE @RESULTS INT;
DECLARE @RETURN INT;
EXEC @RETURN = RETURNSTATEMENTPROCEDURE 20,23,@RESULT = @RESULTS OUTPUT;
SELECT @RESULTS
SELECT @RETURN;


---CREATE STORE PROCEDURE AND HANDLE EXCEPTION
GO
IF EXISTS(SELECT * FROM SYS.procedures WHERE name = 'TRY_PROCEDURE')
	DROP PROCEDURE TRY_PROCEDURE;
GO
CREATE PROCEDURE TRY_PROCEDURE(@INPUT INT,@OUTPUT INT,@AVERAGERESULT  DECIMAL OUT)
AS
BEGIN
DECLARE @SUMOFAMOUNT MONEY;
DECLARE @AVERGAGEOFEMPLOYE INT;
SELECT @AVERGAGEOFEMPLOYE = COUNT(DISTINCT EMPLOYEENUMBER) 
FROM TRANSAC WHERE EMPLOYEENUMBER BETWEEN 2023 AND 2025;
SELECT @AVERGAGEOFEMPLOYE;
---GETING TOTAL AMOUNT BETWEEN THE EMPLOYEE
SELECT @SUMOFAMOUNT = SUM(AMOUNT) 
FROM TRANSAC WHERE EMPLOYEENUMBER BETWEEN 2023 AND 2025;
SELECT @SUMOFAMOUNT;
--TOTAL CALCULATION
SET @AVERAGERESULT = @SUMOFAMOUNT/@AVERGAGEOFEMPLOYE

END
GO

--ANOTHE WAY
--SELECT SUM(AMOUNT) AS TOTALAMONUTBYEMPLOYEE,COUNT(EMPLOYEENUMBER),EMPLOYEENUMBER AS COUNTS
--FROM TRANSAC 
--WHERE EMPLOYEENUMBER BETWEEN 100 AND 123
--GROUP BY  EMPLOYEENUMBER;
--TO JUSTIFY ABOVE CODE
--SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = 100;

--THIS WILL PRODUCE RESULT WITH NO ERROR
DECLARE @RESULT INT
EXEC TRY_PROCEDURE 223,227,@RESULT OUTPUT 
SELECT @RESULT;

--WHAT IF WE GIVE VALUE WHICH NOT FOUND OF 0/0 ERROR
GO
DECLARE @RESULT INT
EXEC TRY_PROCEDURE 2023,2025,@RESULT OUTPUT 
SELECT @RESULT;
GO

SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER BETWEEN 4 AND 5;

--IMPORTANT NULL DIVDED BY ANY THING WILL BE NULL
SELECT NULL/0;

---PROCEDURE TRY AND CATH
GO
IF EXISTS(SELECT * FROM SYS.procedures WHERE name = 'MATH')
	DROP PROCEDURE MATH;
GO
GO
CREATE PROCEDURE MATH(@ACTION VARCHAR(25),@INPUT INT,@OUTPUT INT,@RESULT INT OUTPUT)
AS 
BEGIN
SELECT 1;
IF @ACTION = 'ADD'
	BEGIN
	    SELECT 1;
		SET @RESULT = @INPUT + @OUTPUT;
	END
IF @ACTION = 'DIVDE'
	BEGIN
		BEGIN TRY
		
				SET @RESULT = @INPUT/@OUTPUT;
		END TRY	
		BEGIN CATCH 
	           SELECT ERROR_LINE(),ERROR_MESSAGE(),
			   ERROR_NUMBER(),ERROR_SEVERITY(),ERROR_STATE(),ERROR_PROCEDURE();
		END CATCH
	END
END
GO
DECLARE @RESULT INT;
DECLARE @ACTIONS VARCHAR;
SET @ACTIONS = 'ADD';
EXEC MATH'DIVDE',10,10,@RESULT OUTPUT;
SELECT @RESULT;

--BUT THIS CODE WILL SHOW YOU DIVIDE BY ZERO ERROR
--TO HANDLE THAT ERROR WE NEED TO USE TRY AND CATCH
---ERROR_LINE(),ERROR_MESSAGE()
--ERROR LINE - WILL TELL IN WHICH LINE ERROR OCCURS
--ERROR MESSSGAE -WHAT TYPE OF ERROR
---ERROR_NUMBER(),ERROR_SEVERITY(),ERROR_STATE(),ERROR_PROCEDURE();
---EROR NUMBERR - TO IDENTITYFY THE ERROR SIMILAR TO EROR MESSAGE
---ERROR SEVERITY WILL TELL YOU HOW IMPORATNT THAT ERROR
---0 TO 10 NORMAL
--10 TO 16 SEVERE
--20 TO 25 BAD
--ERROR PROCEDURE THE PROCEDURE NAME
GO
DECLARE @RESULT INT;
DECLARE @ACTIONS VARCHAR;
SET @ACTIONS = 'ADD';
EXEC MATH'DIVDE',10,0,@RESULT OUTPUT;
SELECT @RESULT;
GO

---THROWING ERROR USING RAISEERROR AND  ERROR
GO
IF EXISTS(SELECT * FROM SYS.procedures WHERE name = 'THRWOERROR')
	DROP PROCEDURE THRWOERROR;
GO
GO
CREATE PROCEDURE THRWOERROR(@INPUT INT)
AS
BEGIN
IF(@INPUT%2 =0)
	BEGIN
	SELECT 'EVEN NUMBER';
	END
ELSE
   --RAISERROR ('ODD  NUMBER THROW',10,1)
   RAISERROR ('ODD  NUMBER THROW',19,1)
   SELECT 'CODE WORKS'
END
GO

---IF WE USE RAISE ERROR WE CAN SET SEVIERTY IF IT LESS THAN 10
--IT WILL AS MESSAGE AND IT WILL LET THE QUERY TO EXCUTE
--GREATER THAN 16 WILL SHOW AS ERROR BUT IT WILL EXCUTE THE CODE AFTER THAT
GO
EXEC THRWOERROR 101;
GO

GO
IF EXISTS(SELECT * FROM SYS.procedures WHERE name = 'THRWOERRORUSINGTHROW')
	DROP PROCEDURE THRWOERRORUSINGTHROW;
GO
GO
CREATE PROCEDURE THRWOERRORUSINGTHROW(@INPUT INT)
AS
BEGIN
IF(@INPUT%2 =0)
	BEGIN
	SELECT 'EVEN NUMBER';
	END
ELSE
   THROW 5478,'ODD DIGIT OCCURS',1
   SELECT 'CODE WORKS'
END
GO
---IT WILL THROW AS ERROR 
--AFTER THE STATEMENT WONT EXECUTE IT WILL TERMINATE
GO
EXEC THRWOERRORUSINGTHROW 1;


--AGGREGATE QUERIES
SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
SUM(NUMBERATTENDANCE) AS SUMOFDAYS
FROM
[dbo].[tblAttendance]
GROUP BY 
[EmployeeNumber],YEAR([AttendanceMonth])
ORDER BY EMPLOYEENUMBER;



SELECT * FROM [dbo].[tblAttendance];

--OVER()

--WITHOUT OVER
SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
SUM(NUMBERATTENDANCE) AS SUMOFDAYS
FROM
[dbo].[tblAttendance]
GROUP BY 
[EmployeeNumber],YEAR([AttendanceMonth])
ORDER BY EMPLOYEENUMBER;

--WITH OVER
---OVER USED TO GET A UNIQUE RESULT FROM
--A WINDOW FUNCTION ADD TO THE END OF THE ROW

--IN THIS CONTEXT WE ARE USING OVER
--TO SUM OF THE SUM OF ALL THE COLUMN

--IT WILL SUM THE ENTIRE COLUMN VALUES
SELECT SUM([NumberAttendance]) FROM TBLATTENDANCE;
--

---
SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
MIN(NUMBERATTENDANCE) OVER() AS SUMOFDAYS 
FROM
[dbo].[tblAttendance];
---FIND THE PERCENTAGE OF THE ATTENDANCE
---NUMBER OF DAYS DIVIDED BY TOTALUMBER OF DAYS AND MULTIPLY BY HUNDRED
-- IN THIS EXAMPLE I HAVE MULTIPLIED THE 100 AFTER OVER CLASS
SELECT  
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
CONVERT(DECIMAL(18,9),NumberAttendance)/SUM([NumberAttendance]) OVER() * 100 AS PERCENTAGES
FROM
[dbo].[tblAttendance];

--WINDOW FUNCTION
--DEFINITON THESE FUNCTION PERFOM OPERATION ON SET OF 
--ROWS AND PROVIDE A SINGLE RESULT

--There are several types of window functions 
--available in SQL Server, including:

--Aggregate functions: These functions 
--perform calculations on a set of rows and 
--return a single result, 
--such as SUM, COUNT, AVG, MIN, and MAX.

--Ranking functions: These functions assign a rank 
--to each row in the result set based on a specified 
--order, such as ROW_NUMBER, RANK, and DENSE_RANK.

--Analytic functions: These functions calculate 
--values based on a group of rows and return 
--the result for each row in the group, 
--such as LAG, LEAD, FIRST_VALUE, and LAST_VALUE.

--Using window functions in SQL Server 
--can help simplify complex queries and 
--improve query performance by reducing 
--the number of subqueries and temporary 
--tables needed to achieve the desired results.

--PARTISION BY ---IMPORTANT 
--IT REFINES THE ROW

SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
MIN(NUMBERATTENDANCE) OVER() AS SUMOFDAYS 
FROM
[dbo].[tblAttendance];
--EXAMPLE PARTION BY 
--REFINES THE ROW OR SET THE WINDOW FUNCTION TO PERFORM 
--ON THE BASIS OF WHICH GROUP ROW
SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
--INSIDE OVER WHICH COLUMN NEED TO GROUP AND THEN LET THE WINDOW FUNCTION TO PERFORM 
---ACTION ON THE BASIS OF GROUPED ROW.
SUM([NumberAttendance]) OVER(PARTITION BY EMPLOYEENUMBER, YEAR([AttendanceMonth]))
FROM [dbo].[tblAttendance];

--- THE ABOVE QUERY GROUPING BY EMPLOYEENUMBER THEN YEAR
--- WHICH IS EQUIVALENT TO
--- GROUP BY EMPLOYEENUMBER,YEAR

--EXAMPLE 1 --IMPORTANT

SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
[NumberAttendance],
--EXAMPLE PARTION BY 
--REFINES THE ROW OR SET THE WINDOW FUNCTION TO PERFORM 
--ON THE BASIS OF WHICH GROUP ROW
--INSIDE OVER WHICH COLUMN NEED TO GROUP AND THEN LET THE WINDOW FUNCTION TO PERFORM 
---ACTION ON THE BASIS OF GROUPED ROW.
--IN THIS CONTEXT HOW RUNNIG TOTAL WORKS
---GROUP BY EMPLOYEE NUMBER AND YEAR SO IT WILL SUM THE NUMBER OF ATTENDENCE 
--IT IS THE WINDOW FUNCTION THATS WHY I AM SAYING
--WHEN YOU WANNA SEE THE RUNING TOTAL YOU NEED TO ORDER BY THE COLUMN WHICH HAS UNIQUE VALUES 
-- IT SUM UP AND ADD IN THE LAST OF EACH COLUMN IN THE GROUP
--ORDERBY CLAUSE WILL LET YOU TO SEE THE CHANGES PROGRESIVELY
SUM([NumberAttendance]) OVER(PARTITION BY EMPLOYEENUMBER, YEAR([AttendanceMonth])  ORDER BY [NumberAttendance])
FROM [dbo].[tblAttendance];






--EXAMPLE 2 --IMPORTANT

SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
[NumberAttendance],
--WHEN YOU WANNA SEE THE RUNING TOTAL YOU NEED TO ORDER BY THE COLUMN WHICH HAS UNIQUE VALUES 
---BUT IN THIS CASE I ORDER BY THE CLAUSE WHICH HAS DUPLIATE VALUE EXAMPLE EMPLOYEE NUMBER 
---RUNNIG TOTAL CAN'T SEE ONLY THE SUM WILL ADDED TO EACH OF THE ROWS IN THE GROUP
SUM([NumberAttendance]) OVER(PARTITION BY EMPLOYEENUMBER, YEAR([AttendanceMonth])  ORDER BY EMPLOYEENUMBER)
FROM [dbo].[tblAttendance];

--EXAMPLE 3 --IMPORTANT

SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]) AS YEARS,
[NumberAttendance],
--WHEN YOU WANNA SEE THE RUNING TOTAL YOU NEED TO ORDER BY THE COLUMN WHICH HAS UNIQUE VALUES 
---BUT IN THIS CASE I ORDER BY THE CLAUSE WHICH HAS DUPLIATE VALUE EXAMPLE [NumberAttendance]  
---RUNNIG TOTAL CAN SEE BUT IT DIFFERENTLY  ADDED TO EACH OF THE ROWS IN THE GROUP
SUM([NumberAttendance]) OVER(PARTITION BY EMPLOYEENUMBER, YEAR([AttendanceMonth])  ORDER BY [NumberAttendance])
FROM [dbo].[tblAttendance];









---FOLLOWING AND PRECEDING 
---EXAMPLE 1 = > 10,12,23 
---FOLLOWING 23 AND PRECEDING 10 FOR VALUE 12
---EXAMPLE 2 = > 12,23
---FOLLOWING 23 AND NO PRECEDING FOR VALUE 12 THEN WINDOW FUNCTION PERFORM(SUM IN THIS CASE) 
---EXAMPLE 3 =>10,12 NO FOLLOWING 10 PRECEDING FOR VALUE 12
--LOO AT THE QUERY AND CALULATE THE 56 VALUE YOU WILL GET THE ACCESS
GO
SELECT
[EmployeeNumber],
YEAR([AttendanceMonth]),
[NumberAttendance],
SUM([NumberAttendance]) OVER(PARTITION BY EMPLOYEENUMBER,YEAR([AttendanceMonth])  ORDER BY [AttendanceMonth] ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING )
FROM [dbo].[tblAttendance];
GO


--UNBOUNDED AND CURRENT ROW 
--BY DEFAUT ORDER BY WITH PARTITION WILL HAVE 
--ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
--UNBOUNDED MENTION IT AS ENTIRE TABLE ROW 
--CURRENT MENTION IT AS 0 
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
SUM(tblAttendance.NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) ORDER BY tblAttendance.AttendanceMonth
ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
FROM
tblAttendance;

--UBOUNDED ENTIRE TABLE
--IT VERY HARD TO UNDERSTAND
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
SUM(tblAttendance.NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) ORDER BY tblAttendance.AttendanceMonth
)FROM
tblAttendance;


--PLAYING WITH PRCEDING AND FOLLOWING 
--IN UNBOUNDED AND CURRENY ROW

--UNBOUNDED PRECEDING AND FOLLWOING WILL GET TOTAL SUM OF ALL ROWS 
--YOU THE RESULT
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
SUM(tblAttendance.NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) ORDER BY tblAttendance.AttendanceMonth 
ROWS BETWEEN UNBOUNDED PRECEDING  AND  UNBOUNDED FOLLOWING) 
FROM
tblAttendance;


--IN HERE IT WILL TAKE THE CURRENT ROW WHICH MEANS THE PRESENT ROW
--THEN IT WILL SUM UP THE NEXT ONE FOLLOWING
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
SUM(tblAttendance.NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) ORDER BY tblAttendance.AttendanceMonth 
ROWS BETWEEN CURRENT ROW  AND  UNBOUNDED FOLLOWING) 
FROM
tblAttendance;


--0 PRECDEING AND UNBOUDED 
--CURRENT ROW AND SUM IT TO THE END LIKE THAT THOUGHT BUT ITS NOT WORKING
--IT WILL GET THE CURRENT ROW AND SUM IT TO THE NEXT FOLLOWING ONLY
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
SUM(tblAttendance.NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) ORDER BY tblAttendance.AttendanceMonth 
ROWS BETWEEN 0 PRECEDING AND  UNBOUNDED FOLLOWING) 
FROM
tblAttendance;

--REVERSE RUNNING TOTAL
--INSTEAD OF UNBOUNDED WE CAN USE THE 999
--IT WILL GET THE CUURENT ROW AND SUM IT ENTIRE ROW
--AND NEXT ROW SUM IT TO THE ENTIRE GROUP 
--THAT'S HOW WE CAN GET THE REVERSE RUNNIG TOTAL
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
SUM(tblAttendance.NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) ORDER BY tblAttendance.AttendanceMonth 
ROWS BETWEEN 0 PRECEDING AND  999 FOLLOWING) 
FROM
tblAttendance;

--IN THIS CONTEXT
---GROUP BY WORKS IF GROUP IT WITH 
---WITH EMPLOYEENUMBER 
--OTHER COLUMN I CAN USE AGGREAGTE FUNCTION TO GET 
--THE  RESULT OTHER WISE I NEED MENTION OTHER COLUMN
--TO GROUP BY SATEMENT TO GROUP IT

--EXAMPE
SELECT 
EmployeeNumber,
SUM(NumberAttendance)
FROM
[tblAttendance]
GROUP BY EmployeeNumber
ORDER BY EmployeeNumber;

--HERE WE GROUP IT WITH EMPLOYEENUMBER AND OTHER COLUMN USE 
--AGGREGATE FUNCTION FOR SUM(DAYS)
--IF THIS IS NOT GIVEN SUM(DAYS) WE SHOULD USE IT WITH
--GROUP BY DAYS

--ERROR
SELECT 
EmployeeNumber,
NumberAttendance
FROM
[tblAttendance]
GROUP BY EmployeeNumber
ORDER BY EmployeeNumber;

--WITHOUT ERROR BUT NOT DESIRED RESULT

SELECT 
EmployeeNumber,
NumberAttendance
FROM
[tblAttendance]
GROUP BY EmployeeNumber,NumberAttendance
ORDER BY EmployeeNumber;








--PARTISION BY CONTINUES
--OVER REPRESENTS SUMING OF ROWS OR
--PERFORM ACTION IN A ROWS
--IF WE USE OVER WE SHOULD HAVE WINDOW FUNCTION BEFORE 
---THIS FUNCTION ACCEPTS ALL COLUMN IT WILL DONE BY ROWS
--IT SEND ALL THE COLUMN VALUE ILKE IMAGINE THEN PEFORM 
--SUMATION AND RETURN TOTAL AMOUNT TO EACH AND EVRY ROW..


SELECT 
EmployeeNumber,
SUM(NumberAttendance) OVER() AS TOATALS,
YEAR(AttendanceMonth)
FROM
[tblAttendance]
--GROUP BY EmployeeNumber,YEAR(AttendanceMonth)
ORDER BY EmployeeNumber;

---USING PARTISION BY
--IT GROUP IT IN ROW WISE 
--IN THIS CONTEXT 
--IT GROUP IT BASED ON EMPLOYENUMBER THEN
--EACH VALUE OF THAT GROUP GIVEN TO WINDOW FUNCTION
--SUM IT FOR THAT GROUP AND ADD TO END OF THE ROWS
--OF A PARTICULAR GROUP OF EACH VALUES
SELECT 
EmployeeNumber,
SUM(NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER ) AS TOATALS,
YEAR(AttendanceMonth)
FROM
[tblAttendance]
--GROUP BY EmployeeNumber,YEAR(AttendanceMonth)
ORDER BY EmployeeNumber;

--PARTITION BY AND ORDER BY
--HERE ORDER BY ATTENDANCE MONTH WILL SHOW YOU 
--RUNNIG TOTAL
--OREDER BY NUMBER OF ATTENDECE WILL GIVE THE SAME RESULT 
--BUT IN DIFFERENT ORDER
SELECT 
EmployeeNumber,
NumberAttendance,
SUM(NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER ORDER BY AttendanceMonth) AS TOATALS,
YEAR(AttendanceMonth)
FROM
[tblAttendance]
--GROUP BY EmployeeNumber,YEAR(AttendanceMonth)
--ORDER BY EmployeeNumber;







SELECT EMPLOYEE_ID,
IF(EMPLOYEE_ID%2 != 0 AND NAME NOT LIKE '%M')  
BEGIN
   SALARY
END
ELSE
0
FROM EMPLOYEES;

---CASE SATEMENT IN SQL DATABASE
--THIS IS HOW WE CAN USE CASE SATEMENT IN SQLDATABASE
SELECT EMPLOYEE_ID,
CASE
    WHEN EMPLOYEE_ID%2 != 0 AND NAME NOT LIKE 'M%' THEN SALARY
    ELSE 0
END AS BONUS
FROM EMPLOYEES;

---SHORT CASE AND IF
UPDATE  SALARY
SET SEX = (CASE 
            WHEN SEX = 'm' 
            THEN  'f'
            ELSE  'm'
          END)
;

-- PRECEDING AND FOLLOWING 
--FOLLOWING AND PROCEDING SHOULD USED WITH ORDER BY CLAUSE
-- ROW AND PRECEDING AND FOLLOWING ARE WINDOW FUNCTION 
--PREDING WILL MAKE AS SUM ONE COLUMN BEFORE 14+12 = 26 
--IN THIS CONTEXT
SELECT 
EmployeeNumber,
NumberAttendance,
SUM(NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER 
ORDER BY AttendanceMonth ROWS BETWEEN 1 PRECEDING AND 0 FOLLOWING) AS TOATALS,
YEAR(AttendanceMonth)
FROM
[tblAttendance];

GO
--FOLLOWING
--DOWN ONE ROW SUM IT 
--HERE I WERE USING SUM() FUNCTION OS THAT WHY IT HAS BEEN 
--SUM IT
SELECT 
EmployeeNumber,
NumberAttendance,
SUM(NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER 
ORDER BY AttendanceMonth ROWS BETWEEN 0 PRECEDING AND 1 FOLLOWING) AS TOATALS,
YEAR(AttendanceMonth)
FROM
[tblAttendance]

--fOLLOWING USED WITH MIN 
--COMPARE TOP WITH DOWN ONE AND CHOOSE THE MIN VALUE 
--14 ,12 12 CHOOSED
SELECT 
EmployeeNumber,
NumberAttendance,
MIN(NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER 
ORDER BY AttendanceMonth ROWS BETWEEN 0 PRECEDING AND 1 FOLLOWING) AS TOATALS,
YEAR(AttendanceMonth)
FROM
[tblAttendance]


--IF BOTH SIDE UBOUNDED IT WILL FIND THE VALUE ACCORDING TO THE GROUP
SELECT 
EmployeeNumber,
NumberAttendance,
MIN(NumberAttendance) OVER(PARTITION BY EMPLOYEENUMBER 
ORDER BY AttendanceMonth ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS TOATALS,
YEAR(AttendanceMonth)
FROM
[tblAttendance]

--WITH SATEMENT
--WILL CREATE A TEMPRORY TABLE AND USE IT FOR 
--NEXT FIRST SELECT STATEEMENT

--WITH SHOULD WRITTEN INSIDE THE BATCH
--WITH FOLLOWED BY SELECT SHOULD BE USED (IF NOT SYNTAX ERROR)
GO
WITH TBLS AS
(SELECT * FROM DATAS WHERE DATAS.DateOfBirth > '2000-02-09'),
TBLS2 AS 
(SELECT * FROM TRANSAC)

SELECT * FROM TBLS INNER JOIN TBLS2 ON TBLS.EmployeeNumber = TBLS2.EMPLOYEENUMBER;

---TRY TO ACCESS THE SECOND TABLE SEPARATELY IT WON'T WORK 
---ALL THE TABLE TEMP WILL USED IN SINGLE SELECT STATEMENT
SELECT * FROM TBLS2

--TRY TO ACCESS AGAIN THAT TABLE
--INVALID OBJECT NAME
SELECT * FROM TBLS;
GO
---SELF JOIN
BEGIN TRAN
--ALTER TABLE DATAS
--ADD MANAGER BIGINT;

UPDATE DATAS
SET MANAGER = ((DATAS.EmployeeNumber-123)/10) + 123;

--SELECT D.EmployeeNumber,D.EmployeeFirstName,COUNT(D.MANAGER),E.EmployeeFirstName,E.EmployeeNumber
--FROM DATAS AS D LEFT JOIN DATAS AS E
--ON D.EmployeeNumber = E.MANAGER
--GROUP BY D.EmployeeNumber,D.EmployeeFirstName,E.EmployeeFirstName,E.EmployeeNumber;

--SELECT DATAS.EmployeeFirstName,DATAS.EmployeeNumber,COUNT(DATAS.MANAGER)
--FROM 
--DATAS
--GROUP BY DATAS.EmployeeNumber,DATAS.MANAGER,DATAS.EmployeeFirstName ORDER BY MANAGER;

SELECT DATAS.MANAGER,COUNT(DATAS.EmployeeNumber) FROM DATAS
GROUP BY DATAS.MANAGER 
ORDER BY DATAS.MANAGER;

SELECT * FROM DATAS WHERE MANAGER = 223;
--SELECT* FROM DATAS;

ROLLBACK TRAN

GO


---ANALYTIC FUNCTION
--FIRST_VALUE() -- WILL GET THE FIRST VALUES OF THE LIST
--LAST_VALUES() --WILL GET THE LAST NUMBER OF LIST


--SIMPLE EXAMPLE
SELECT FIRST_VALUE(PRODUCTNAME) FROM STOCKS;
--THE ABOVE EXAMPLE JUSTIFIY'S THAT IT WILL USED WITH OVER CLAUSE

--BY DEFAULT
--WITHOUT ROWS ORDER BY CLASS WORK LIKE THIS(IMPLICITLY ROWS ARE LIKE THIS)
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
SUM(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth 
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM
tblAttendance;

--IN THIS EXAMPLEIT WILL PICK THE FIRST VALUE IN THE GROUP
--WITHOUT ORDER BY IT HAS NOT WORKING 
--I DON'T KNOW WHY
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
FIRST_VALUE(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth ) AS FIRST_VALUE
FROM
tblAttendance;

--IN THIS EAMPLE WITHOUT ROWS OR RANGE
--BY DEFAULT IT WILL HAVE UNBOUNDED PRECEDING AND CURRENT ROW I GUESS
-- AS YOU MAY GUESS THAT IT WILL RESULT TOP FROM THE GROUP FOR THE FIRDT_MONTH
---LAST FROM THE GROUP FOR LAST MONTH
--BUT IT WON'T WORK THAT WAY 
--BECAUES AS PER DOCUMENTTAION 
--FIRST VALUE AND LAST VALUE IN FUNCTION SHOULD BE USED WITH ROWS OR RANGE 
--OTHER WISE UNDESIRED RESULT WILL GET


SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
FIRST_VALUE(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth ) AS FIRST_VALUE,
LAST_VALUE(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth ) AS LAST_VALUE
FROM
tblAttendance;


--LAG AND LEAD
--LAG WILL PICK THE VALUE FROM THE PREVIOUS ROW FROM THE CUURENT ROW
--LEAD WILL PICK THE NEXT VALUE FROM THE CURRENT ROW
--HERE IS THE EXAMPLE TO UNDERSTAND THE lALG AND LEAD
--NO USE ROWS OR RANGE IN LAG AND LEAD
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
LAG(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth ) AS LAGS,
LEAD(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth ) AS LEADS
FROM
tblAttendance;

--LEAD AND LAG WHICH HAS NULL VALUE NEXT OR PREVIOUS VALUE NOT
--THERE IN A GROUP
SELECT 
tblAttendance.EmployeeNumber,
YEAR(tblAttendance.AttendanceMonth),
tblAttendance.NumberAttendance,
LAG(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth ) AS LAGS,
LEAD(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth ) AS LEADS,
FIRST_VALUE(tblAttendance.NumberAttendance)
--IT WILL FETCH THE FRIST VALUE(EQIVALENT TO LAG) AND LAST VALUE(EQUIVALENT TO LEAD)
--IN THIS EXAMPLE 1 PRECEDING MEANS PREVIOUS VALUE 
--1 FOLLOWING MEANS LAST VALUE ABOVE THREE VALUE THREE VALUE ONLY BE CONSIDERED
--ONE PRECDING ONE VALUE AND CURRENT VALUE AND 1 FOLLOWING LAST VALUE ABOVE THREE
--FIRST AND LAST WILL GET FOR EACH SET
--IF PRECEDING NOT THERE IT WILL FETCH THE DEFAULT VALUE ALS FOR  FOLLOWING
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth 
ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS FIRST_VALUE,
LAST_VALUE(tblAttendance.NumberAttendance)
OVER(PARTITION BY EMPLOYEENUMBER,YEAR(tblAttendance.AttendanceMonth) 
ORDER BY tblAttendance.AttendanceMonth 
ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS LAST_VALUE
FROM
tblAttendance;


--CUM_DIST AND PERCENT_RANKING
--CUM_DIST -> DOES PROVIDES SNO / GROUP COUNT
--BUT IF THE COLUMN IN THE ORDER BY CLASS ARE SAME IT WILL 
--CALULATE BASED ON MAX MIMUM VALUE IN THE TOTAL COLUMN
--BOTH MUST HAVE THE OVER CLASS WITH ORDER BY 
---PERCENT_RANKING -> PROIIDES SNO-1/GROUP COUNT -1
--PERCENT_RANKING -> WHICH PROVIDES O INDEX TO LEN-1
--NOT OFTEN USED


--CUME_DIST MEANS CUMMULATIVE DIFFERENCE
--

GO
SELECT 
tblAttendance.EmployeeNumber,
tblAttendance.NumberAttendance,
CUME_DIST() OVER(PARTITION BY tblAttendance.EmployeeNumber ORDER BY tblAttendance.AttendanceMonth),
PERCENT_RANK() OVER(PARTITION BY tblAttendance.EmployeeNumber ORDER BY tblAttendance.AttendanceMonth)
FROM
tblAttendance;

--HERE THE WITH DIFFRERNT COLUMN IN ORDER BY
--IF THE COLUMN HAS DUPLIACATES IT WILL TAKE THE MAX(ROWNO)/TOTAL COUNT GROUP
--SAME VALUE FOR THE DUPLICATE ROWS


SELECT 
tblAttendance.EmployeeNumber,
tblAttendance.NumberAttendance,
CUME_DIST() OVER(PARTITION BY tblAttendance.EmployeeNumber ORDER BY tblAttendance.NumberAttendance) AS CUME_DIST,
PERCENT_RANK() OVER(PARTITION BY tblAttendance.EmployeeNumber ORDER BY tblAttendance.NumberAttendance) AS PERCENT_RANK
FROM
tblAttendance;

--LOOK AT THE VAUE 1 IN THIS EXAMPLE GROUP WHICH EANS PARTITION BY EMPLOYEE NUMBER
--GROUP COUNT 22 AND DIVDE BY SNO
--DUPLICATE VALUE IN NUMBER ATTENDENCE FOR 11
--SO ANSWER WILL BE
---TO JUSTIFY THAT USE CALCULAOR FOR 2/22
--HERE  DATA O WRONG
SELECT CONVERT(decimal(18,9),2/22);

--FOR PERCENT_RANKINGS
--LOOK AT THE VAUE 4 IN THIS EXAMPLE GROUP WHICH EANS PARTITION BY EMPLOYEE NUMBER
--GROUP COUNT 21(0 STARTS) AND DIVDE BY SNO
--DUPLICATE VALUE IN NUMBER ATTENDENCE FOR 14
--SO ANSWER WILL BE
---TO JUSTIFY THAT USE CALCULAOR FOR 4/21
--HERE  DATA O WRONG
SELECT CONVERT(decimal(18,9),4/21);



--PERCENTILE CONT
SELECT 
tblAttendance.EmployeeNumber,
tblAttendance.NumberAttendance,
PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY tblAttendance.NumberAttendance) OVER(PARTITION BY tblAttendance.EmployeeNumber)
FROM
tblAttendance;


SELECT 
COUNT(*),
SUM(NumberAttendance),
CONVERT(DECIMAL(9,4),SUM(NumberAttendance)/COUNT(*)),
AVG(NumberAttendance)
FROM
tblAttendance
WHERE EmployeeNumber = 123
GROUP BY EmployeeNumber;


--PERCENTILE CONT AND PERCENTILE DIST
--PERCENTILE CONT WILL GIVE YOU THE MEADIAN
--MEDIAN
--12346
---MEADIAN WILL BE 3
--1234
--MEADIAN WILL  BE 3.5

SELECT 
DISTINCT tblAttendance.EmployeeNumber,
PERCENTILE_CONT(1) WITHIN GROUP (ORDER BY tblAttendance.NumberAttendance) OVER(PARTITION BY tblAttendance.EmployeeNumber)
FROM
tblAttendance;

--TO JUSTIFY THAT MEADIAN WILL BE 11 COLUMN 24 IS ANSWER
SELECT 
tblAttendance.EmployeeNumber,
tblAttendance.NumberAttendance
FROM
tblAttendance
WHERE tblAttendance.EmployeeNumber = 123;



---50% OF THE MEADIAN USER
--MEADIN WILL BE 11 - 24 AND 12 - 14
--SUM 38/2 19 WILL BE MEADIN
--19- 50% OF 19  WILL BE ANSWER
SELECT 
DISTINCT tblAttendance.EmployeeNumber,
PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY tblAttendance.NumberAttendance) OVER(PARTITION BY tblAttendance.EmployeeNumber)
FROM
tblAttendance;


--ROW NUMBER,  IT WILL GIVE YOU THE SERIAL NUMBER -1,2,3
--IT WILL RESTART BASED ON THE GROUP
--DENSE RANK   --IT WILL IF IT HAS DUPLICATE IT WILL HAVE THE NUMBER AND NEXT NUMBER
--WILL CONTINUE AFTER THE NEXT NUMBE
--1,1,2,3,3,4
--RANK
--IF IT HAS DUPLICATE IT WILL HAVE THE SAME VALUE 
--BUT IT WON'T CONTINUE IT WILL FOLLOW THE ROWS NEXT
--IT CAN BE USEFULL BUT I DON'T KNOW WHERE TO USE IT
--1,1,1,4,5,6,6,8

SELECT 
T1.EmployeeNumber,
T1.AttendanceMonth,
ROW_NUMBER() OVER(PARTITION BY T1.EMPLOYEENUMBER ORDER BY T1.ATTENDANCEMONTH) AS ROWNUMBER,
RANK() OVER(PARTITION BY T1.EMPLOYEENUMBER ORDER BY T1.ATTENDANCEMONTH) AS RANKS,
DENSE_RANK() OVER(PARTITION BY T1.EMPLOYEENUMBER ORDER BY T1.ATTENDANCEMONTH) AS DENSE_RANKS
FROM
tblAttendance AS T1
INNER JOIN
(SELECT * FROM tblAttendance UNION ALL SELECT * FROM tblAttendance) AS T2
ON T1.EmployeeNumber = T2.EmployeeNumber;

---NILE
---IT WILL SEGRIAGTE THE ROW NUMBER 10
---SO IT HAS 22 VALUES ROW NUMBER WILL BE APLLIED 10
--111,222,33,44,55,66,77,88,99,10,10
--THIS HOW IT SEGRIGATES
SELECT
tblAttendance.EmployeeNumber,
tblAttendance.AttendanceMonth,
tblAttendance.NumberAttendance,
ROW_NUMBER() OVER(PARTITION BY tblAttendance.EmployeeNumber ORDER BY tblAttendance.AttendanceMonth),
NTILE(10) OVER(PARTITION BY tblAttendance.EmployeeNumber ORDER BY tblAttendance.AttendanceMonth) 
FROM
tblAttendance;


--ADDING TOTALS
SELECT 
DATAS.Department,
tblAttendance.EmployeeNumber,
tblAttendance.AttendanceMonth,
tblAttendance.NumberAttendance,
SUM(tblAttendance.NumberAttendance) OVER(PARTITION BY tblAttendance.EmployeeNumber)
FROM
DATAS INNER JOIN
tblAttendance
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
ORDER BY Department,EmployeeNumber,AttendanceMonth;


SELECT SUM(tblAttendance.NumberAttendance) FROM tblAttendance;

--IN ANOTHER WAY
SELECT 
DATAS.Department,
tblAttendance.EmployeeNumber,
tblAttendance.AttendanceMonth,
tblAttendance.NumberAttendance
--SUM(tblAttendance.NumberAttendance) OVER(PARTITION BY tblAttendance.EmployeeNumber)
FROM
DATAS INNER JOIN
tblAttendance
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
---ORDER BY Department,EmployeeNumber,AttendanceMonth;
--IT WILL GIVE THE SPECIFIC TOTAL TO THE EMPLOYEE AND IT'S CATEGORIES 
UNION
SELECT 
DATAS.Department,
tblAttendance.EmployeeNumber,
NULL AS NUMBER,
SUM(tblAttendance.NumberAttendance) AS TOTAL
FROM
tblAttendance INNER JOIN
DATAS
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
GROUP BY  DATAS.Department,tblAttendance.EmployeeNumber
ORDER BY DATAS.Department,tblAttendance.EmployeeNumber;


---ABOVE CODE JUSTIFYS THAT IF YOU ARE NOT HAVING EQULA NUMBER OF COLUMN 
--JUST GIVE IT NULL
--IN ASCENDING ORDER NULL WILL COMES BEFORE THE DATA
--DECENDING IT WIL COME AFTER THE DATA

---THE ABOVE UNION STATEMENT COMBINED THE UNIQUE VALUES 
---LEFT WILL RETURN THE DATA USING JOINS AND GROPU BY
---RIGHT SIDE WILL RETURN THE SUMMARY(SUM) BASED ON THE EMPLOYEE NUMBER , DEPARTMENT
--SUMMARY COLUMN WITH OTHER COLUMNS SUMMARY ADDEED IN THE GROUP OF THE LEFT TABLE



--THE ABOVE QUERY CAN BE WRITTEN UP LIKE THIS 
SELECT 
 DATAS.Department,
 tblAttendance.EmployeeNumber,
 SUM(tblAttendance.NumberAttendance)
FROM
tblAttendance
INNER JOIN
DATAS
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
GROUP BY ROLLUP(DATAS.Department,tblAttendance.EmployeeNumber);

--IT'S JUST PROVES THE ABOVE QUERY
SELECT 
DATAS.Department,
SUM(tblAttendance.NumberAttendance)
FROM
tblAttendance
INNER JOIN
DATAS
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
GROUP BY DATAS.Department;



--I IT RECON RIGHT IT WILL GIVE SUM BECAUSE WE USE SUM IN THE 
--QUERY STATEMENT IT WILL SUM UP THE VALUES OF DEPARTEMNT THEN EMPLOYEENUMBER
--UNION IT TOGETHER

--TO JUSTIFY THAT HOW IT'S WORKING 
-- I WILL ADD THE NEW ROW NUMBER ATTENDANCE COLUMN
-- IT WILL GROUP IT SUM() DEPARTMENT
---DEPARTMENT,EMPLOYEENUMBER
---DEPARTMENT,EMPLOYEENUMBER,NUMBERATTENDANCE IT HAS NOT HAS DUPLICATE SO EACH VALUE 
--WILL BE ADDED
SELECT 
 DATAS.Department,
 tblAttendance.EmployeeNumber,
 SUM(tblAttendance.NumberAttendance)
FROM
tblAttendance
INNER JOIN
DATAS
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
GROUP BY ROLLUP(DATAS.Department,tblAttendance.EmployeeNumber,tblAttendance.NumberAttendance);




--TO JUSTIFY THE ABOVE QUERY
--ABOVE COMERCIAL RETURN 264-17 ROWS
--BECAUSE IT HAS EACH ROW SUM IF WE REDUSE IT WE WILL GET 247 ROWS

SELECT 
 DATAS.Department,
 tblAttendance.EmployeeNumber,
 SUM(tblAttendance.NumberAttendance),
  GROUPING(tblAttendance.EmployeeNumber) AS TOTALGROUPING,
 GROUPING_ID(tblAttendance.EmployeeNumber,DATAS.Department) AS GROPING_ID
FROM
tblAttendance
INNER JOIN
DATAS
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
GROUP BY ROLLUP(DATAS.Department,tblAttendance.EmployeeNumber,tblAttendance.NumberAttendance)
HAVING DATAS.Department = 'Commercial'
--WE NEED TO REDUSE EACH ROW SUM ABOVE QUERY

SELECT 
 DATAS.Department,
 tblAttendance.EmployeeNumber,
 SUM(tblAttendance.NumberAttendance),
 COUNT(*)
FROM
tblAttendance
INNER JOIN
DATAS
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
GROUP BY DATAS.Department,tblAttendance.EmployeeNumber,tblAttendance.NumberAttendance
HAVING DATAS.Department = 'Commercial'
ORDER BY  DATAS.Department,tblAttendance.EmployeeNumber

--GROUPING ID AND GROUPING
--WHERE IT HAS NULL IT WILL ADD THE VALUES LIKE INT BOTH
SELECT 
 DATAS.Department,
 tblAttendance.EmployeeNumber,
 SUM(tblAttendance.NumberAttendance),
  GROUPING(tblAttendance.EmployeeNumber) AS TOTALGROUPING,
 GROUPING_ID(tblAttendance.EmployeeNumber,DATAS.Department) AS GROPING_ID
FROM
tblAttendance
INNER JOIN
DATAS
ON tblAttendance.EmployeeNumber = DATAS.EmployeeNumber
GROUP BY ROLLUP(DATAS.Department,tblAttendance.EmployeeNumber)


---DEEP EXPLANATION ON ROLLUP,GROUPIN SETS, AND CUBE
CREATE TABLE COUNTRYDATA(
  CONTENT VARCHAR(50),
  COUNTRY VARCHAR(45),
  CITY VARCHAR(45),
  POPULATION BIGINT
);
--INSERT INTO COUNTRYDATA VALUES ('ASIA','CHINA','TOKYO',5000),
--('ASIA','CHINA','TIMBER',8000),
--('ASIA','CHINA','TIMBER',4000),
--('ASIA','CHINA','ZOMOYA',3000),
--('ASIA','INDIA','CHENNAI',15000),
--('ASIA','INDIA','TRICHY',6500),
--('ASIA','INDIA','TRICHY',6500),
--('EROUPE','SPAIN','ATLANDA',9000),
--('EROUPE','SPAIN','ATLANDA',400),
--('EROUPE','FRANCE','SWIS',3500),
--('EROUPE','TRYIS','SWIS',2500),
--('NORTHMAERICA','CANADA','TOTANHAM',500),
--('NORTHMAERICA','USA','NEWYORK',1500),
--('NORTHMAERICA','USA','NEWYORK',1500);

--I HAVE THEREE COLUMN WITH VALUES
SELECT * FROM COUNTRYDATA
ORDER BY CONTENT,COUNTRY,CITY;

--GROUPING SET WIL GROUP YOU ANY MANNER YOU WANT 

--IT WILL GIVE THE CONTENT BASED SUM
SELECT CONTENT,SUM(POPULATION) FROM COUNTRYDATA
GROUP BY CONTENT;

--COUNTRY BASED
SELECT COUNTRY,SUM(POPULATION) FROM COUNTRYDATA
GROUP BY COUNTRY;

--CITY BASED SUM
SELECT CITY,SUM(POPULATION) FROM COUNTRYDATA
GROUP BY CITY;

--THE ABOVE CODE WILL GET THE RESULT IN DIFFERENT MANNERS
--TO ALL IN A SINGLE LINE USE GROUPING SET
SELECT CONTENT,COUNTRY,CITY,SUM(POPULATION) FROM COUNTRYDATA
GROUP BY GROUPING SETS(CONTENT,COUNTRY,CITY);
--THE ABOVE QUERY RESULTS 
---1.CITY WISE 
--COUNTRY WISE
--CONTENT WISE

--ADDING ENTIRETY BY ()
--TOTAL,CITY,COUNTRY,CONTENT BECAUSE USING ORDER BY
SELECT CONTENT,COUNTRY,CITY,SUM(POPULATION) FROM COUNTRYDATA
GROUP BY GROUPING SETS(CONTENT,COUNTRY,CITY,())
ORDER BY CONTENT,COUNTRY,CITY;

--HERE USING PARANTHESIS TO SPECIFY WITH TYPE OF SUM I NEED
--ENTIRE
--CITY
--CONTENT,COUNTRY
SELECT CONTENT,COUNTRY,CITY,SUM(POPULATION) FROM COUNTRYDATA
GROUP BY GROUPING SETS((CONTENT,COUNTRY),(CITY),())
ORDER BY CONTENT,COUNTRY,CITY;


---USING ROLLUP
--ENTRIE
--CONTENT
--CONTENT,COUNTRY
--CONTENT,COUNTRY,CITY
SELECT CONTENT,COUNTRY,CITY,SUM(POPULATION) FROM COUNTRYDATA
GROUP BY ROLLUP(CONTENT,COUNTRY,CITY)
ORDER BY CONTENT,COUNTRY,CITY;


---CUBE WILL GIVE ALL THE COMBINATION
--NEED TO ANALYSIS WHICH COMBINATIONS ARE GIVEN
SELECT CONTENT,COUNTRY,CITY,SUM(POPULATION) FROM COUNTRYDATA
GROUP BY CUBE(CONTENT,COUNTRY,CITY)
ORDER BY CONTENT,COUNTRY,CITY;



--SPATIAL AGGREGATES USED TO REFER THE GEOMENTRY

BEGIN  TRAN
CREATE TABLE GEOSPACE(
XYZ GEOMETRY,
DESCRIPTION VARCHAR(50),
GEOID INT PRIMARY KEY IDENTITY(1,1) 
);

INSERT INTO GEOSPACE 
VALUES(geometry::STGeomFromText('POINT(0 3)',0),'FIRSTPONT'),
(geometry::Point(0,4,0),'SECONDPOINT'),
(geometry::STGeomFromText('MULTIPOINT ((1 2),(2 2),(3 2))',0),'THIRDPOINT')

SELECT * FROM GEOSPACE;
ROLLBACK TRAN


--THESE ARE THE WAYS WE CAN SET THE GEMETRY POINT 

--SCALAR FUNCTION
--SCALAR FUNCTION ARE USED TO RETURN ONE VALUES
--ADVANTAGE OVER SCALAR OVER SP
--SCALAR CAN BE USED IN THAT SELECT STATEMENT
GO
CREATE FUNCTION RETURNSUM(@AMOUNT INT)
RETURNS INT
AS
BEGIN
	 RETURN @AMOUNT + 1
END
GO

SELECT AMOUNT FROM TRANSAC;

--SCALAR FUNCTION SHOULD BE INVOKED WITH SCHEMA
SELECT DBO.RETURNSUM(AMOUNT) FROM TRANSAC;

GO
--WRITING THE SCALR FUNCTION WITH TO COUNT THE NUMBER OF TRANSACTION
CREATE FUNCTION TOTALTRANSACTION (@EMPLOYEENUMBERS INT)
RETURNS INT
AS
BEGIN
	DECLARE @COUNTSOFTRANSAC INT;
	SELECT @COUNTSOFTRANSAC = COUNT(*) FROM TRANSAC
	WHERE EMPLOYEENUMBER = @EMPLOYEENUMBERS;
	RETURN @COUNTSOFTRANSAC
END
GO

SELECT DATAS.EmployeeNumber,DBO.TOTALTRANSACTION(EmployeeNumber) AS COUNTOFTRANSAC FROM DATAS;

--ABOVE QUERY WE GOT THE RESULT THROUGH FUNCTION

---THIS HOW WE CAN GET THE SAME RESULT WITH JOINS
SELECT 
DATAS.EmployeeNumber,
CASE WHEN TRANSAC.EMPLOYEENUMBER IS NULL THEN 0
	ELSE COUNT(*)
	END AS TOTALTRANSACCOUNT
FROM 
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATAS.EmployeeNumber,TRANSAC.EMPLOYEENUMBER
--HAVING COUNT(*) = 0;

---IN SOME OTHE WAY
SELECT 
DATAS.EmployeeNumber,
COUNT(TRANSAC.EmployeeNumber) AS TOTALCOUNT
FROM 
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATAS.EmployeeNumber
ORDER BY DATAS.EmployeeNumber

---ABOVE TWO QUERY RUN AT THE SAME TIME 
--YOU WILL COSTOF EACH QUERY BUT PERFROMANCE WISE 
--JOIN RUNS FASTER NOT  SCALR FUNCTION I HAVE ASKED THE 
--QUESTION IN UDEMY
SELECT *,DBO.TOTALTRANSACTION(EmployeeNumber) AS COUNTOFTRANSAC FROM DATAS;



--INLINE TABLE FUNCTION 
GO
CREATE FUNCTION TABLEEMPLOYEEFUNCTION (@EMPLOYEENUMBER INT)
RETURNS TABLE AS RETURN
(
SELECT * FROM  WHERE EmployeeNumber 
= @EMPLOYEENUMBER
)
GO

--IF YOU USE IT COLUMN SELECTION 
--YOU WILL GET THIS ERROR
--Msg 4121, Level 16, State 1, Line 3725
--Cannot find either column "DBO" or the user-defined function or aggregate \
--"DBO.INLINETABLEFUNCTION", or the name is ambiguous.
SELECT DBO.TABLEEMPLOYEEFUNCTION(DATAS.EMPLOYEENUMBER) FROM DATAS;


--COORECT WAY USING IN THE fROM CLAUSE
GO
SELECT * FROM dbo.TABLEEMPLOYEEFUNCTION(123);
GO
---TO FETCH THE DATA USING WHERE CLAUSE
SELECT *  FROM DATAS
WHERE EXISTS(SELECT * FROM dbo.TABLEEMPLOYEEFUNCTION(DATAS.EmployeeNumber));

--EXISTS MUST UNDERSTAND MUCH DEEPER
--THE ABOVE QUERY RETURNS THAT THE TABLE WHICH HAS ROW FOR THAT EMPLOYEENUMBER
--IT WILL RETURN THAT ROW IF EXISTS TRUE THAT ROW IN THE DATAS TABLE WILL RETURN

--ANOTHER WAY OF WRITING TE SAME QUERY
SELECT * FROM DATAS
WHERE DATAS.EmployeeNumber = (SELECT TOP 1 EmployeeNumber FROM DBO.TABLEEMPLOYEEFUNCTION(DATAS.EmployeeNumber));

SELECT 
DATAS.EmployeeNumber
FROM
DATAS
INNER JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATAS.EmployeeNumber;

SELECT * FROM STOCKS;
SELECT * FROM SOLDCOUNT;


--RELEARNING JOINS
--INNER JOIN WILL GET THE COMMON RESULT
SELECT 
*
FROM 
STOCKS
INNER JOIN
SOLDCOUNT
ON STOCKS.PRODUCTNAME = SOLDCOUNT.PRODUCTNAME;


--LEFT JOINS MERGING LEFT WITH RIGHT IF RIGHT DOES'T
--HAS ANY EQUAL VALUES IT WILL NULL
--RIGHT HAS VALUES WHICH LEFT DOESN'T HAS WILL LAPSED
--TOOTH PASTE LAPSE
--SPORTS SUNSCREEN AND MOUTH WASH WLL BE PRESERVED
SELECT 
*
FROM 
STOCKS
LEFT JOIN
SOLDCOUNT
ON STOCKS.PRODUCTNAME = SOLDCOUNT.PRODUCTNAME;



---RIGHT JOIN
--RIGHT VALUE WILL BE PRESERVED AND LEFT VALUE WILL BE LAPSED
--LEFT DOESN'T HAS ANY VALUE WHICH RIGHT HAS WILL BE NULL
--TOOTH PASTE PRESERVED
--SPORTS SUNSCREEN AND MOUTH WASH WLL BE LAPSED
SELECT 
*
FROM 
STOCKS
RIGHT JOIN
SOLDCOUNT
ON STOCKS.PRODUCTNAME = SOLDCOUNT.PRODUCTNAME;


--FULL OUTRE JOIN 
--IT WILL THE COMBINATION OF BOTH LEFT AND RIGHT JOIN
----TOOTH PASTE PRESERVED
--SPORTS SUNSCREEN AND MOUTH WASH WLL BE PRESERVED
SELECT 
*
FROM 
STOCKS
FULL OUTER JOIN
SOLDCOUNT
ON STOCKS.PRODUCTNAME = SOLDCOUNT.PRODUCTNAME;


--CROSSJOIN EACH VALUE GET THE COMBINATION OF ALL DIFFERENT VALUE IN OTHER TABLE
--NEED TO UNDERSTAND LITILE BIT DEEPER
SELECT 
*
FROM 
STOCKS
CROSS JOIN
SOLDCOUNT;


--MULTI STATEMENT TABLE FUNCTION
GO
CREATE FUNCTION MULTITABLETRANSAC(@EMPLOYEENUMBER INT)
RETURNS @TBL TABLE
(
AMOUNT SMALLMONEY,
DATEOFTRANSACTION SMALLDATETIME,
EMPLOYEENUMBER INT
)
AS
BEGIN
INSERT INTO @TBL(AMOUNT,DATEOFTRANSACTION,EMPLOYEENUMBER)
SELECT AMOUNT,DATEOFFTRANSACTION,EMPLOYEENUMBER FROM TRANSAC 
WHERE EMPLOYEENUMBER = @EMPLOYEENUMBER
RETURN
END
GO

--THE ABOVE FUNCTION IS MULTI STATEMENTS TABLE FUNCTION
--HERE THE DIFFERENCE BETWEEN INLINE TABLE AND MULTI LINE TABLE FUNCTION IS
--THE WE CAN IMLPLEMENT LOGIC INSIDE IT LIKE COMPLICATE BUT IT UPTO SOME LEVEL 
--NEED TO DO R&D ON FUNCTION

--THIS HOW WE CAN USE IT
SELECT * FROM DBO.MULTITABLETRANSAC(123);

--APPLY WHICH HELPS TO JOIN THE ESULT OF FUNCTION(MULTIL)
--TWO WAYS CROSS AND OUTER
--OUTER TI WILL ASSIGN THE ROW NULL 

--IT CAN BE USED IN THE WHERE CLAUSE
SELECT * FROM DATAS
WHERE (SELECT COUNT(*) FROM DBO.MULTITABLETRANSAC(DATAS.EmployeeNumber)) > 0;



--IT CAN BE USED IN THE FROM CAULSE ALSO
SELECT DATAS.EmployeeNumber,(SELECT COUNT(*) FROM DBO.MULTITABLETRANSAC(DATAS.EmployeeNumber)) FROM DATAS;


--APPLY OUTER 
SELECT 
* 
FROM 
DATAS
INNER JOIN 
(SELECT COUNT(*) FROM DBO.MULTITABLETRANSAC(DATAS.EmployeeNumber)) AS T2
ON DATAS.EmployeeNumber = T2.EmployeeNumber;

--WE CAN'T USE IT IN JOINS THE FUNCTION IN SQL
SELECT 
* 
FROM 
DATAS
OUTER APPLY  
(SELECT * FROM DBO.MULTITABLETRANSAC(DATAS.EmployeeNumber)) AS T2;
---LOOK AT 130 THOUGH FUNCTION RETURN ANY ROW BUT IT FETCH THE 
--CORRESPONDING REORD 
--IN THE TABLE




--RESTUDY CROSS AND OUTER APPLY
--IT IS PRIMARLY USED FOR JOIN OPERATOR
--SIMPLE LAYMAN TERMS WHEN YOU WANNA 
--JOIN A FUNCTION OR A SUBQUERYWITH TABLE IT'S USED.
--CROSS LIKE INNER JOIN AND OUTER IS LIKE 
--(OUTER JOIN IT'S LIKE COMBINATION OF BOTH LEFT AND RIGHT JOIN)
GO
WITH  T1 AS
(SELECT * FROM DATAS 
WHERE EmployeeNumber  BETWEEN 123 AND 125 ) 


--HERE I HAVE CREATED THE TABLE(CTE) WHICH 
--FILETER THE RECORD BASED ON ID 123 TO 125
SELECT 
* 
FROM
T1
CROSS APPLY
(SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = T1.EMPLOYEENUMBER) AS T2


WITH  T2 AS
(SELECT EmployeeNumber,Department FROM DATAS 
WHERE EmployeeNumber  BETWEEN 123 AND 125
UNION SELECT 2000,'HR'
) 

SELECT 
* 
FROM
T2
OUTER APPLY
(SELECT * FROM TRANSAC WHERE EMPLOYEENUMBER = T2.EMPLOYEENUMBER) AS T3

--IN THIS EAXMPLE I HAVE USED OUTER APPLY
--THE MAIN DIFFERENCE IT'S WHEN THERE IS NO MATCHING VALUE FOR
--THE BASE TABLE IT WILL PUT IN THE RESULT SO OTHER VALUE WILL BE NULL
--SIMILLAR TO LEFT JOIN



--THIS SECNARIO INSTEAD OF CREATING THE TABLE VALUED FUNCTION LIKE 
--INLINE TABLE FUNCTION YOU CAN USE SUBQUERY WHICH IS  ALSO WORK
--OR YOU CAN IMAGINE AS FUNCTION
--IT WILL GET THE RECORD AND JOIN IT IT SATISFIES THE CONDTION
--SO EACH AND EVER ROW (ONE BY ONE) IT WILL JOIN
--GET THE ONE ROW AND COMPARE WHICH ALL THE ROW MATCHING IN A SECOND TABLE

GO
SELECT 
* 
FROM 
DATAS
CROSS APPLY  
(SELECT * FROM DBO.MULTITABLETRANSAC(DATAS.EmployeeNumber)) AS T2;
---LOOK AT 130 THOUGH FUNCTION RETURN NULL ROW SO 
---IT WON'T FETCH THE CORRESPONDING REORD 
--IN THE TABLE
--IMPORTANT IT PEFORMANE CAUSING QUERY IT TAKE ONE MINUTE







---SYNONYMS
--FAILED NOT TRUE NEED TO DO R&D ON THIS ADVANTAGE
--1.MAIN ADVANTAGE OF SYNONYM IS WHEN YOU CREATE A VIEW WHICH 
--THE NAME OF THE TABLE IN WHICH THE VIEW IS CREATED BASICALLY 
--WHEN YOU ALTER THE BASE TABLE NAME VIEW GETS AFFECTED 
--BUT CREATE SYNONYM IT WON'T GET AFFECTED IT MORE LIKE THE POINTER 
--OF THE TABLE.


--WE CAN CREATE SYNONYM FOR THE TABLE WHICH IS RUNNING 
--IN A DIFFERENT SERVER
--CARETE SYNONYM SYNONYMNAME SERVERNAME.DATASBASENAME.SCHEMANAME.OBJECTNAME

--3.WE CAN USE IT IN FUNCTION ANS SP AND VIEWS AS WELL


--SELECT * FROM AJAYDATAS;
--DROPING SYNONYM 
---DROP SYNONYM DATASSYNONYM;
BEGIN TRAN 
CREATE SYNONYM DATASSYNONYM
FOR DBO.DATAS

--I AM CHANGING THE NAME OF THE TABLE
--ADVANTAGE 1 FAILED HERE
EXEC sp_rename 'DATAS','AJAYDATAS';

--INSER UPDATE AND DELETE WILL GET UPDATE IN THE BOTH SIDE
INSERT INTO DATASSYNONYM VALUES(1150,'FOSTER','JAIN','SUPER','AB11234578',GETDATE(),'HR',NULL)

SELECT * FROM DATAS
SELECT * FROM DATASSYNONYM;

--WE CAN CREATE THE SYNONYM FOR THE TABLE WHICH IS NOT PRESENT
--IT WON'T THROW ERROR BUT WHE YOU SELECTING IT WILL THROW SOME ERROR

CREATE SYNONYM NOTPRESENT
FOR AJAYVIN
--THROW ERROR
---SELECT * FROM  NOTPRESENT
ROLLBACK TRAN

--THESE ARE CALLED SQLMETADATA
SELECT * FROM SYS.synonyms;

GO
---DYNAMIC SQL 
--SO THIS DYNAMIC SQL 
--NEED TO STUDY ABOUT PROS AND CONS OF IT
DECLARE @COMMNAD VARCHAR(255) = 'SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = 129';
EXEC (@COMMNAD);
GO
--WE COULD CHANGE THE QUERY IN THE NEXT STEPS
DECLARE @COMMNAD VARCHAR(255) = 'SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = 129';
SET @COMMNAD = 'SELECT * FROM DATAS WHERE EMPLOYEENUMBER = 129'
EXEC (@COMMNAD);
GO
---CONSEQUENSE OF SQL INJECTION 
--1=1 ALWAY WILL BECAME TRUE
DECLARE @COMMAND VARCHAR(255) = 'SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER =';
DECLARE @PARAM1 VARCHAR(255) = '129 OR 1=1';
EXEC (@COMMAND + @PARAM1);

GO
--TO PREVENT THE SQL INJECTION
DECLARE @COMMAND NVARCHAR(255) = N'SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER BETWEEN @EMPID AND @EMPID2';
DECLARE @PARAM1 NVARCHAR(255) = N'129';
DECLARE @PARAM2 NVARCHAR(255) = N'130';

--THIS HOW WE CAN PREVENT SQLINJECTION AS WELL
EXEC SYS.SP_EXECUTESQL @STATEMENT = @COMMAND , @PARAMS = N'@EMPID INT, @EMPID2 INT' ,@EMPID = @PARAM1, @EMPID2 = @PARAM2;

GO
--WITHOUT NVARCHAR
---IT WILL THROW SOME EXCEPTION LIKE THIS
---Procedure expects parameter '@statement' of type 'ntext/nchar/nvarchar'.
--THAT'S HOW THE SP WRITTEN 
--I RECON NVARCHAR FOR ACCEPCTING UNICODE CHARACTER AND LIKE @  NOT TRUE 
DECLARE @COMMAND VARCHAR(255) = 'SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER BETWEEN @EMPID AND @EMPID2';
DECLARE @PARAM1 VARCHAR(255) = '129';
DECLARE @PARAM2 VARCHAR(255) = '130';

--THIS HOW WE CAN PREVENT SQLINJECTION AS WELL
EXEC SYS.SP_EXECUTESQL @STATEMENT = @COMMAND , @PARAMS = '@EMPID INT, @EMPID2 INT' ,@EMPID = @PARAM1, @EMPID2 = @PARAM2;

--TO PROVE THAT 
--@ CAN BE ACCEPECTED USING VARCHAR
DECLARE @CHARS VARCHAR(20);
SET @CHARS = '@AJAY'
SELECT @CHARS;

GO
--ANOTHER WAY EXCUTE THE SQLQUERY
--WORKING ODD
--DECLARE AS VARCHAR BUT PASS AS INT BELOW
DECLARE @COMMAND NVARCHAR(255) = N'SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER BETWEEN @PARAM1 AND @PARAM2';
DECLARE @PARAM1 NVARCHAR(255) = 129;
DECLARE @PARAM2 NVARCHAR(255) =135;

--THIS HOW WE CAN PREVENT SQLINJECTION AS WELL
EXEC SYS.SP_EXECUTESQL
@COMMAND , 
N'@PARAM1 INT, @PARAM2 INT', 
@PARAM1,
@PARAM2;

GO
--WORKING
DECLARE @COMMAND NVARCHAR(255) = N'SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER BETWEEN @PARAM1 AND @PARAM2';
DECLARE @PARAM1 INT = 129;
DECLARE @PARAM2 INT =135;

--THIS HOW WE CAN PREVENT SQLINJECTION AS WELL
EXEC SYS.SP_EXECUTESQL
@COMMAND , 
N'@PARAM1 INT, @PARAM2 INT', 
@PARAM1,
@PARAM2;


--THOUGH WE ARE USING SP_EXECUTESQL IT NOT PREVENT FOREVER 
--IT LEAST LIKELY TO HAVE SQL INJECTION

GO


---SUBQUERY STARTS 
BEGIN TRAN
SET STATISTICS IO ON
SET STATISTICS TIME ON
SELECT 
* 
FROM TRANSAC 
INNER JOIN 
DATAS
ON TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber
WHERE DATAS.EmployeeLastName LIKE 'Y%'
ROLLBACK TRAN


---WITH SUB QUERY
--IT VERY HARD JUDGE IT WHICH IS FASTER BECAUSE THE RESULT IS VARIYING
BEGIN TRAN
SET STATISTICS IO ON
SET STATISTICS TIME ON
SELECT 
* 
FROM TRANSAC  
WHERE TRANSAC.EMPLOYEENUMBER IN (SELECT DATAS.EmployeeNumber FROM DATAS WHERE DATAS.EmployeeLastName LIKE 'Y%')
ROLLBACK TRAN

---WHERE NOT OPERATOR 
SELECT * FROM TRANSAC
WHERE TRANSAC.EmployeeNumber NOT IN 
(SELECT DATAS.EmployeeNumber 
FROM DATAS WHERE 
DATAS.EmployeeLastName  LIKE 'Y%')
ORDER BY TRANSAC.EMPLOYEENUMBER;
--HERE I HAVE GOT LEFT JOIN 
--WHY SO? IT JUST BECAUSE THE VALUES FROM THE OUTER TABLE COMPARED WITH INNER 
--INNER TABLE VALUES 
--OUTER TABLE DOESN'T NEED TO MATCH THE EMPLOYEE NUMBER IN INNER TABLE
--IT SERCHING THE VALUES WHICH IS NOT IN THE INNER TABLE
--SO VALUE IN THE OUTER TABLE ALL WILL IN A RESULT
--1,2 ARE IN RESULT
--WRONG

--IT JUST BECAUSE OF LEFT JOIN WILL BRING THE MATCHING VALUES IN THE 
--BOTH TABLES AND THE VALUES WHICH IS NOT MATCHED IN THE RIGHT TABLE 
--WILL BE ALSO RETRIVED AS SINGLE TABLE BUT THE CONSEQUENT VALUES ARE NULL 




SELECT * FROM TRANSAC
WHERE TRANSAC.EmployeeNumber  IN 
(SELECT DATAS.EmployeeNumber 
FROM DATAS WHERE 
DATAS.EmployeeLastName NOT LIKE 'Y%')
ORDER BY TRANSAC.EMPLOYEENUMBER;
--INNER JOIN BECAUSE THE RESULT FROM THE INNER TABLE VALUE
--WHICH IS MATCHED WITH OUTTER WILL RESULT
--VALUES WHICH IS IN THE 
--1,2 IT'S NOT IN RESULT


---ANY AND ALL AND SOME
--ANY SHOUD BE USED WITH COMPARISION OPERATOR
--IT LIKE MULTIPLE VALUES COMPARING WITH OR OPERATOR
--SOME IS SAME AS ANY
--1 => ANY (126,127,128,129) - 1 IS COMPARED WITH ALL VALUES 
--IF ANY ONE TRUE IT WILL RETURN THAT VALUES

--ALL IT IS ALSO USED WITH COMPARISION OPERATOR
--IT LIKE MULTIPILE VALUES COMPARING WITH AND
--1 => ALL (126,127,128,129) - 1 IS COMPARED WITH ALL VALUES 
--IF EVERY VALUES TRUE IT WILL RETURN THAT VALUES


SELECT 
*
FROM 
TRANSAC
WHERE TRANSAC.EmployeeNumber <> ANY
(
SELECT
DATAS.EMPLOYEENUMBER
FROM
DATAS
WHERE DATAS.EmployeeLastName LIKE 'Y%'
)
ORDER BY TRANSAC.EMPLOYEENUMBER;

--ABOVE QUERY RESULTS 
--1 => <>126 OR <>127 OR <>128 OR <>129 



SELECT 
*
FROM 
TRANSAC
WHERE TRANSAC.EmployeeNumber <> ALL
(
SELECT
DATAS.EMPLOYEENUMBER
FROM
DATAS
WHERE DATAS.EmployeeLastName LIKE 'Y%'
)
ORDER BY TRANSAC.EMPLOYEENUMBER;


--ABOVE QUERY RESULTS 
--1 => <>126 AND <>127 AND <>128 AND <>129 

--FROM IN SUBQUERY CLEARLY KNOWN


---SELECT CONCEPT IN SUBQUERY
SELECT
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,
DATAS.EmployeeLastName,
COUNT(DATAS.EmployeeNumber) AS TOTALTRANSACTION
FROM 
DATAS
INNER JOIN 
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeLastName  LIKE 'Y%'
GROUP BY DATAS.EmployeeNumber,DATAS.EmployeeFirstName,DATAS.EmployeeLastName;

GO
--PARTISTION BY GROUP IT 
--BUT IT WON'T GROUP IT TO THE SINGLE COLUMN
--IT JUST PERFORM SOME FUNCTION ADD  IN THE GROUP 
SELECT
DATAS.EmployeeNumber,
COUNT(*) OVER(PARTITION BY DATAS.EmployeeNumber) AS TOTALTRANSACTION
FROM 
DATAS
INNER JOIN 
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeLastName  LIKE 'Y%';


--COMPARING JOINS WITH SUBQUERY
--SUBQUERY IS FASTER THAN THE JOINS IN THIS CASE
SELECT
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,
DATAS.EmployeeLastName,
COUNT(DATAS.EmployeeNumber) AS TOTALTRANSACTION
FROM 
DATAS
INNER JOIN 
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeLastName  LIKE 'Y%'
GROUP BY DATAS.EmployeeNumber,DATAS.EmployeeFirstName,DATAS.EmployeeLastName;


---USING SUBQUERY
--I TOUGHT THE ALL THE EMPLOYEENUMER WILL BE MATCHING 
--BUT RESULT OF THE OUTER QUERY MATCH WITH THE INNER QUERY
--THIS KNOWN AS CORRELATED QUERY 
--INNER QUERY DEPANDS ON OUTER QUERY THAT KNOWN AS CORRELATED QUERY 
SELECT 
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,
DATAS.EmployeeLastName,
(SELECT COUNT(TRANSAC.EMPLOYEENUMBER) FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber) AS TOTALCOUNT
FROM 
DATAS
WHERE DATAS.EmployeeLastName LIKE 'Y%';

---JUST PRACTISE THE OWN QUESTION
SELECT 
*,
(SELECT DATAS.EmployeeFirstName FROM DATAS WHERE DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER) AS EMPLOYEENAME
FROM 
TRANSAC
WHERE TRANSAC.AMOUNT >= (SELECT MAX(TRANSAC.AMOUNT) FROM TRANSAC)


--SELECT * FROM DATAS WHERE DATAS.EmployeeNumber = 673;

--COMPARISION OF SUBQUERY EXISTS CLAUSE AND JOIN AMONG ALL OF THSES
--WHICH IS FASTER


--THE ABOVE SUBQUERY 
--FIRST OUTER AND INNER QUERY RUN TOGETHER TO GET THE RESULT
--THE OUT WILL BE FOUR OF OUTER QUERY
--THAT VALUES IS COMPARED WITH INNER QUERY THATS WHY IT'S FASTER
SELECT 
*,
(SELECT COUNT(TRANSAC.EMPLOYEENUMBER) FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber)
FROM
DATAS
WHERE DATAS.EmployeeLastName LIKE 'Y%';

--SAME RESULT USING EXISTS CLAUSE

--EXISTS CLAUSE UNDERSTANDING 
--WHEN IT RETURNS AS ROW THAT EQUIVALENT ROW IN TRANSAC TABLE RETURN LIKE I THOUGHT
--BUT IT'S NOT 
SELECT 
*
FROM
TRANSAC
WHERE EXISTS(SELECT * FROM DATAS WHERE DATAS.EmployeeLastName LIKE 'y%')
ORDER BY TRANSAC.EMPLOYEENUMBER;



--BELOW CODE TRY GET THE RESULT
SELECT 
*
--(SELECT * FROM DATAS WHERE DATAS.EmployeeLastName LIKE 'y%' AND DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER) AS DOSEEXISTS
FROM
TRANSAC
WHERE EXISTS(SELECT * FROM DATAS WHERE DATAS.EmployeeLastName LIKE 'y%' AND DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER)
ORDER BY TRANSAC.EMPLOYEENUMBER;

--STEP 1 SELECT * FROM DATAS WHERE DATAS.EmployeeLastName LIKE 'y%'
--ABOVE CODE WILL RETURN 4 ROWS
--SELECT * FROM DATAS WHERE DATAS.EmployeeLastName LIKE 'y%' AND DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
---THAT FOUR ROW COMPARED WITH EMPLOYEEID IN TRANSAC


--COMPARE ALL WITH  JOINS
SELECT
TRANSAC.*
FROM 
DATAS
INNER JOIN 
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeLastName  LIKE 'Y%'
GROUP BY TRANSAC.EmployeeNumber,TRANSAC.DATEOFFTRANSACTION,TRANSAC.AMOUNT;


---SUBQUERY
SELECT 
*,
(SELECT COUNT(TRANSAC.EMPLOYEENUMBER) FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber)
FROM
DATAS
WHERE DATAS.EmployeeLastName LIKE 'Y%';
--THUS COMPARING WITH JOINS EXISTS WORK SAME
--COMPARING ALL THREE SUBQUERY IS FASTER

--UNDERSTANDING THE EXISTS CLAUSE

SELECT 
* 
FROM
DATAS AS T
WHERE EXISTS(SELECT * FROM DATAS WHERE DATAS.EmployeeNumber BETWEEN 129 AND 135 AND DATAS.EmployeeNumber = T.EmployeeNumber);

---LEET CODE

SELECT TRANSAC.EMPLOYEENUMBER FROM TRANSAC
WHERE AMOUNT IN (SELECT  DISTINCT TRANSAC.AMOUNT FROM TRANSAC)
GROUP BY EMPLOYEENUMBER
ORDER BY EMPLOYEENUMBER


BEGIN TRAN
CREATE TABLE PERSON
(
  ID INT PRIMARY KEY,
  EMAIL VARCHAR(85) 
)

INSERT INTO PERSON
VALUES (1,'john@example.com'),
(2,'bob@example.com'),
(3,'john@example.com');

DELETE FROM PERSON
WHERE PERSON.ID NOT IN
(SELECT MIN(PERSON.ID) FROM PERSON
GROUP BY PERSON.EMAIL)

SELECT * FROM PERSON;
ROLLBACK TRAN


SELECT (UPPER(LEFT('aJAY',1)) + LOWER(RIGHT('aJAY',LEN('aJAY')-1)));

SELECT LEFT('aJAY',1)

SELECT RIGHT('AJAY',LEN('AJAY'))

SELECT RIGHT('AJAY',LEN('AJAY')-1);


---TOP G CATEGORIES

SELECT 
*,
RANK() OVER(PARTITION BY ViewByDepartment.Department ORDER BY ViewByDepartment.DATEOFFTRANSACTION) AS RANKS
FROM 
dbo.ViewByDepartment
INNER JOIN 
DATAS
ON ViewByDepartment.EmployeeNumber = DATAS.EmployeeNumber
WHERE RANKS <= 5
ORDER BY ViewByDepartment.Department;


--ALIAS COLUMN WON'T WORK IN THE WHERE CLAUSE 
--ORDER BY ,WHERE THEN SELECT THE BALANCE ROWS


--CORRECT THAT WE NEED TO WRITE SOME SUBQUERIES TECNIQUE
SELECT * FROM
(SELECT 
ViewByDepartment.*,
RANK() OVER(PARTITION BY ViewByDepartment.Department ORDER BY ViewByDepartment.DATEOFFTRANSACTION) AS RANKS
FROM 
dbo.ViewByDepartment
INNER JOIN 
DATAS
ON ViewByDepartment.EmployeeNumber = DATAS.EmployeeNumber
) AS MYTABLE
WHERE RANKS <= 5
ORDER BY MYTABLE.Department;


--THUS WE CAN GET THE EACH CATEGORIES TOP STATEMENT
--USING RANK ANALYTIC FUNCTION

GO
--WITH STATEMENT
WITH MYTABLE AS 
(SELECT 
ViewByDepartment.*,
RANK() OVER(PARTITION BY ViewByDepartment.Department ORDER BY ViewByDepartment.DATEOFFTRANSACTION) AS RANKS
FROM 
dbo.ViewByDepartment
INNER JOIN 
DATAS
ON ViewByDepartment.EmployeeNumber = DATAS.EmployeeNumber
)
,
NOTRANSACTION AS
(
  SELECT 
  DATAS.EMPLOYEENUMBER 
  FROM 
  DATAS
  LEFT JOIN 
  TRANSAC
  ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
  WHERE TRANSAC.EmployeeNumber IS  NULL
)

SELECT * FROM NOTRANSACTION
ORDER BY EMPLOYEENUMBER;

--HERE IS THE CONDITION 
--WE NEED TO GET EMPLOYEENUMBER BUT THOSE AREN'T IN THE TABLE ALSO
--BUT THE THEY ARE SEQUENCE FIND OUT LEFT OVER NUMBERS
SELECT * FROM DATAS WHERE EmployeeNumber = 1;

--THIS GIVE U THE SQUENCE NUMBER 
--2505
--BUT WEARE HAVING THE ID UPTO 1234
--HOW CAN WE RESTRIC IT

SELECT EMPLOYEENUMBER,ROW_NUMBER() OVER(ORDER BY (SELECT (NULL))) AS SNO  FROM TRANSAC
ORDER BY EMPLOYEENUMBER;

---USING TOP
--NOW WE GOT THE SEQUENTION UPTO THE EMPLOYEE NUMBER IN THE TABLE TRANSAC
SELECT TOP 1234 ROW_NUMBER() OVER(ORDER BY (SELECT (NULL))) AS SNO  FROM TRANSAC
ORDER BY EMPLOYEENUMBER;


GO
--NOW WE HAVE ARE JOIN TABLTRANSAC
WITH  COUNTS AS(
SELECT TOP 1234 ROW_NUMBER() OVER(ORDER BY (SELECT (NULL))) AS SNO  FROM TRANSAC
ORDER BY EMPLOYEENUMBER
)

SELECT COUNTS.SNO FROM COUNTS
LEFT JOIN TRANSAC
ON COUNTS.SNO = TRANSAC.EMPLOYEENUMBER
WHERE TRANSAC.EMPLOYEENUMBER IS NULL
ORDER BY COUNTS.SNO

--THIS HOW WE CAN GET THE EMPLOYEE NUMBER WHICH NOT USED IN BOTH TRANSAC
---AND DATAS


---TO JUSTIFY THE ABOVE QUERY IS RIGHT
SELECT * FROM TRANSAC
WHERE EMPLOYEENUMBER = 18;

--IN THIS, CHALLENGING PART IS GENRATING NUMBERS UPTO SOME LENGHT
--WITH OUT WHILE LOOP

--IT CAN BE ALSO DONE WITH CROSS JOINS
--IT WILL TAKE WHILE TO SEE THE RESULT
--THIS HOW WE CAN CREATE NUMBERS
SELECT * FROM sys.all_objects AS T
CROSS JOIN sys.all_objects AS N

--ANOTHER QUESTION TO GET THE LEVEL OR RANGE
GO
WITH  COUNTS AS(
SELECT TOP 1234 ROW_NUMBER() OVER(ORDER BY (SELECT (NULL))) AS SNO  FROM TRANSAC
ORDER BY EMPLOYEENUMBER
),
TABLETRAN2014 AS(
  SELECT * FROM TRANSAC WHERE TRANSAC.DATEOFFTRANSACTION >= '2014-01-01'
  AND TRANSAC.DATEOFFTRANSACTION <= '2015-01-01'
)
---I WANT THE EMPLOYEE NUMBER TO BE BETWEEN THE RANGE OF 2014 TO 15
--THIS LAG AND LEAD GIVE THE NEXT AND PROR VALUE IN THE SEQUENCEOF COLUMN WHICH 
--IS MENTIONED IN THE LAD OR LEAD PARAMETERS 
--SELECT COUNTS.SNO,LAG(COUNTS.SNO) OVER(ORDER BY COUNTS.SNO) AS LAGS,LEAD(COUNTS.SNO) OVER(ORDER BY COUNTS.SNO) AS LEADS  FROM COUNTS
--LEFT JOIN TABLETRAN2014
--ON COUNTS.SNO = TABLETRAN2014.EMPLOYEENUMBER
--WHERE TABLETRAN2014.EMPLOYEENUMBER IS NULL
--ORDER BY COUNTS.SNO

--GETING WHICH IS LAGING
--SELECT COUNTS.SNO,COUNTS.SNO - LAG(COUNTS.SNO) OVER(ORDER BY COUNTS.SNO)  AS LAGS,LEAD(COUNTS.SNO) OVER(ORDER BY COUNTS.SNO) - COUNTS.SNO AS LEADS  FROM COUNTS
--LEFT JOIN TABLETRAN2014
--ON COUNTS.SNO = TABLETRAN2014.EMPLOYEENUMBER
--WHERE TABLETRAN2014.EMPLOYEENUMBER IS NULL
--ORDER BY COUNTS.SNO


--I GONO ADD BOLEAN VALUES IF T HAS RANGE 0 AND IF NOT WILL BE 1
,GROUPS AS
(SELECT 
COUNTS.SNO,
COUNTS.SNO - LAG(COUNTS.SNO) OVER(ORDER BY COUNTS.SNO)  AS LAGS,
LEAD(COUNTS.SNO) OVER(ORDER BY COUNTS.SNO) - COUNTS.SNO AS LEADS,
CASE WHEN COUNTS.SNO - (LAG(COUNTS.SNO) OVER(ORDER BY COUNTS.SNO) - COUNTS.SNO) = 1 THEN 0
	 ELSE 1 END AS GROUPNUMBER 	
FROM 
COUNTS
LEFT JOIN TABLETRAN2014
ON COUNTS.SNO = TABLETRAN2014.EMPLOYEENUMBER
WHERE TABLETRAN2014.EMPLOYEENUMBER IS NULL
)

SELECT 
*,
SUM(GROUPNUMBER) OVER(ORDER BY SNO)
FROM GROUPS
ORDER BY SNO



--PIVOTING 
--REARRANGING THE DATA IN DIFFERENT FORMAT LIKE MORE COLUMN AND LESS ROW
--FOR COMPUTATION

GO
---IMPORTNAT NOTE WHEN YOU WANAA ADD THE DATA TO THE TABLE BUT NOT BY INSERTING 
--INTO IT YOU CAN USE UNION
WITH TABLEPIVOT AS(
SELECT YEAR(DATEOFFTRANSACTION) THEYEAR , MONTH(DATEOFFTRANSACTION) AS THEMONTH,AMOUNT FROM TRANSAC
---THIS HOW WE CAN INSERT IT FOR TEMPRORILY
UNION SELECT 2023,1,100.56
)

---SELECT * FROM TABLEPIVOT WHERE THEYEAR = '2015';

--WE HAVE TO MENTION WHICH VALUES ARE SUM(COLUMNNAME) THEN (FOR) MEANS COLUMN WHICH NEED 
--TO USED THEMONTH AS A COLUMN FOR THE TABLE AND LEFT COLUMN WILL BE CONSIDERED AS ROWS

--REPLACING NULL WITH VALUES
--USING ISNULL

--TIPS TO HAVE A GOOD PIVOT TABLE IS AGREATE THE TABLE VALUES WHEN YOU SELECTING FOR 
--THE PIVOTS  ISNULL([10],0)
SELECT * into tablepivot FROM TABLEPIVOT
PIVOT(SUM(AMOUNT) FOR THEMONTH IN ([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12])) AS PIVOTS
ORDER BY THEYEAR;

GO


---UNPIVOTING THE TABLE HAS BEEN CREATED USING 
--THIS IS HOW WE CAN UNPIVOT THE DATA AND WE CAN'T RETRIVE THE 
--ORIGINAL VALUES
--BUT VALUE ARRANGEMENT HAS BEEN CHANGED BY WHAT YU SEE

SELECT * FROM tablepivot
UNPIVOT(AMOUNT FOR THEMONTH IN (
       [1]
      ,[2]
      ,[3]
      ,[4]
      ,[5]
      ,[6]
      ,[7]
      ,[8]
      ,[9]
      ,[10]
      ,[11]
      ,[12])) AS UNPIVOTS



--------------
--3
--LASTLY SELECTING THE VALUES
SELECT
*
FROM
--1
--WITHOUT USING CTE
--SELECT THE REQUIRED DATA AND NAME IT
(SELECT 
STOCKS.PRODUCTNAME,
STOCKSCOUNTS,
SOLDCOUNT
FROM 
STOCKS
LEFT JOIN 
SOLDCOUNT
ON STOCKS.PRODUCTNAME = SOLDCOUNT.PRODUCTNAME) AS SOURCETABLE
--2
--CHNAGING OR SETING THE ROWS
PIVOT(MAX(SOLDCOUNT) FOR PRODUCTNAME IN ([SOAP],[DRY SHAMPOO],[SUNSCREEN],[SPORTS SUN SCREEN],[HIMALAYA],[MOUTHWASH])) AS MYPIVOT
ORDER BY STOCKSCOUNTS;

---GUID
---IT UNIQUE THOUGH YOU RUN IN SAME TIME ON OTHER COMPUTER
---UNIQUEIDENTIFIER IS TYPE
---128 BITS

BEGIN TRAN 
DECLARE @GUID UNIQUEIDENTIFIER;
SET @GUID = NEWID()
SELECT @GUID 

CREATE TABLE NEWIDS(
GUIDS UNIQUEIDENTIFIER CONSTRAINT NAMEOFGUID DEFAULT NEWID(),
NUMBER INT
)

INSERT INTO NEWIDS (NUMBER) VALUES(1),(2),(3),(4)

SELECT * FROM NEWIDS;
ROLLBACK TRAN

--THE ABOVE CODE EXPLAINS THAT HOW MANY TIME YOU RUNNIG THE CODE
--IT DOESN'T MATTER IT WILL GIVES THE UNIQUE ID ONLY
--BUT IT HAS LARGE PERFORMANCE IMPACT . WHEN YOU APPILED 
--A INDEX ON THE COLUMN BECAUSE THE RANDOM HEXA CODE WILL
--BE GENRARTED EACH TIME WHEN EVER YOU INSERTING IT IT RE ORDERS THE 
--TABLE


BEGIN TRAN 
--IT CAN ONLY USED IN TABLE WITH DEFAULT CONSTRAINT
--CREATE OR ALTER TABLE
--DECLARE @GUID UNIQUEIDENTIFIER;
--SET @GUID = NEWSEQUENTIALID()
--SELECT @GUID 

CREATE TABLE NEWSEQIDS(
GUIDS UNIQUEIDENTIFIER CONSTRAINT NAMEOFGUID DEFAULT NEWSEQUENTIALID(),
NUMBER INT
)

INSERT INTO NEWSEQIDS (NUMBER) VALUES(1),(2),(3),(4)

SELECT * FROM NEWSEQIDS;
ROLLBACK TRAN

--TO MINIMIZE THE PERFORMANCE ISSUE
--INTORDUCED NEWSEQUENTIALID 
---IT WILL GENRATE IT IN THE ORDER BY COMPARING WITH LAST VALUE IN THE 
--TABLE 


----CREATING SEQUENCES 
---WE CAN HAVE CONTROL IN SEQUENCES 
--COMPARE TO IDENTIY GUID AND GUIDSEQUENTIAL

BEGIN TRAN
CREATE SEQUENCE FIRSTSEQUENCE AS BIGINT
--STRATING VALUE
START WITH 1
---INCREMENT VALUE
INCREMENT BY 1
--MINMUM VALUE
MINVALUE 1
--MAX VALUE UPTO THIS VALUE IT WILL APPEND
--AFTER THAT IF YOU GIVE CYLE IT WILL START FROM THE 
--MINVALUE AGAIN
--NO CYCLE IT WON'T START AGIN
MAXVALUE 999999
CYCLE
CACHE 50

--BY GIVING LIKE THAT IT WILL 
-- BY DEFAULT SET THE MINVALUE AND INCREAMENT AS PER THE
--DATATYPE RANGE LIKE BIT
CREATE SEQUENCE SECONDSEQUENCE AS INT

SELECT * FROM SYS.SEQUENCES


ROLLBACK TRAN


---RE SUB QUERISE

--ALL --MULTIPLE AND OPERATOR
SELECT 
* 
FROM
DATAS
WHERE DATAS.EmployeeNumber = ALL(SELECT EmployeeNumber FROM TRANSAC WHERE EmployeeNumber BETWEEN 125 AND 128);

--ANY -- MULTIPLE OR
SELECT 
* 
FROM
DATAS
WHERE DATAS.EmployeeNumber > ANY(SELECT EmployeeNumber FROM TRANSAC WHERE EmployeeNumber BETWEEN 125 AND 128);


--EXSIST CLAUSE
--IN THIS CASE IT WILL RETURN ALL THE RECORDS IT JUST BECAUSE 
--THE SUBQUERY ALWAY RETURN ALL THE ROWS FOR EACH RECORD IN THE DATAS TABLE
SELECT 
* 
FROM
DATAS
WHERE EXISTS (SELECT EmployeeNumber FROM TRANSAC WHERE EmployeeNumber BETWEEN 125 AND 128);


--EXISTS CLAUSE CAN BE USED POWERFULLY WITH
--CORRELATED SUBQUERY

--THE CASE IF EMPLOYEE MADE ANY TRANSACTION THAT EMPLOYEE NUMBER SHOULD RETURN
--IN THIS IT RETRIVE THE DATA FASTER THAT'S WHY EXISTS USED FOR LARGE  DATASET 
--TO RETRIVE THE DATA FASTER
SELECT 
*
FROM
DATAS 
--ORDER BY EmployeeNumber
WHERE
EXISTS 
(SELECT TOP 1 * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber);



--PIVOTING AND UNPIVOTING
SELECT *
FROM
STOCKS
PIVOT(MIN(STOCKSCOUNTS) FOR PRODUCTNAME IN ([SOAP],[DRY SHAMPOO])) AS MYPIVOT

---HERE I AM CREATING THE SEQUENCE
--TRY TO ROLLBAK BUT THE VALUE WON'T CHANGE
GO
BEGIN TRAN
CREATE SEQUENCE NAMEOFSEQUENCE
AS INT
START WITH 1
INCREMENT BY 1
MINVALUE 1
CACHE 50

--SELECT NEXT VALUE FOR NAMEOFSEQUENCE AS NEXTVALUE
CREATE TABLE SEQTABLE
(
   NAMES VARCHAR(MAX),
   ID INT CONSTRAINT NEXTCONSTRAINT DEFAULT NEXT VALUE FOR NAMEOFSEQUENCE
)

INSERT INTO SEQTABLE([NAMES]) VALUES
('AJAY'),('VIJAY')

SELECT * FROM SEQTABLE
ROLLBACK TRAN

--CREATING SEQUENCE IN THE DATABASE
--UNDER PROGRAMMABILITY SEQUENCE HAS BEEN CREATED 
CREATE SEQUENCE NAMEOFSEQUENCE
AS INT
START WITH 1
INCREMENT BY 1
MINVALUE 1
CACHE 50


---CREATING THE NEW COLUMN
ALTER TABLE TRANSAC
ADD  NEXTVALUE INT

--ADDING THE DEFAULT CONSTARINT AND ATTACHING SEQUENCE
--
ALTER TABLE TRANSAC
ADD CONSTRAINT SETDEFAULT DEFAULT NEXT VALUE FOR NAMEOFSEQUENCE FOR NEXTVALUE


---HERE WHEN I RAN AGAIN THIS QUERY MULTIPLE TIME I WILL GET 
--NON CONTINOUS NEXT NUMBER VALUE LIKE IDENTITY
--IT JUST BECAUSE I AM ROLLBAK THE INSERT OPTION 
--NOT ROLLBACKING THE SEQUENCE OPTION
--ABOVE EXAMPLE I AM ROLLING BACK THE SEQUENCE OPTION IT REPEAT THE SAME NUMBER
BEGIN TRAN 

INSERT INTO TRANSAC(EMPLOYEENUMBER,AMOUNT,DATEOFFTRANSACTION)
VALUES(2002,789.63,SYSDATETIME())

SELECT TOP 10 * FROM TRANSAC ORDER BY EMPLOYEENUMBER DESC

ROLLBACK TRAN


--WE CAN RESET THE SEQUENCE ALSO
--IT WILL RESTRAT THE SEQENCE WITH ONE AGAIN
ALTER SEQUENCE NAMEOFSEQUENCE
RESTART WITH 1;


--DROPING THE SEQUENCE 
--DROP THE CONTRAINT
ALTER TABLE TRANSAC
DROP CONSTRAINT SETDEFAULT;

--DROP COLUMN
ALTER TABLE TRANSAC
DROP COLUMN NEXTVALUE;

--DROP SEQUENCE
DROP SEQUENCE NAMEOFSEQUENCE;

SELECT * FROM TRANSAC




---PRACTICE FOR OFFICE

SELECT * FROM DATAS
LEFT JOIN TRANSAC
ON TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber
WHERE (NULL IS NULL)
AND
1 = (IIF(1=1,1,0))
AND
1 = (CASE 'AJAY' 
	WHEN 'AJAY' THEN IIF(DATAS.EmployeeFirstName LIKE 'A%',1,0)
	END 
)

--IMPORTANT KEY NOTES
BEGIN TRAN
SELECT * FROM SOLDCOUNT
SELECT * FROM STOCKS


UPDATE SOLDCOUNT
SET SOLDCOUNT.SOLDCOUNT = SOLDCOUNT + 10
FROM SOLDCOUNT
INNER JOIN STOCKS
ON SOLDCOUNT.PRODUCTNAME = STOCKS.PRODUCTNAME;

SELECT * FROM SOLDCOUNT
SELECT * FROM STOCKS
ROLLBACK TRAN





BEGIN TRAN
CREATE TABLE OCCUPATIONS (
    Name VARCHAR(50),
    Occupation VARCHAR(20)
);
INSERT INTO OCCUPATIONS (Name, Occupation)
VALUES
    ('Jenny', 'Doctor'),
    ('Samantha', 'Doctor'),
    ('Ashley', 'Professor'),
    ('Christeen', 'Professor'),
    ('Meera', 'Singer'),
    ('Priya', 'Singer'),
    ('Jane', 'Actor'),
    ('Julia', 'Actor'),
    ('Ketty', 'Professor'),
    ('Maria', 'Actor');

SELECT 
*
FROM
(
SELECT 
NAME,
Occupation,
ROW_NUMBER() OVER(PARTITION BY OCCUPATION ORDER BY NAME) AS RN
FROM OCCUPATIONS
) 
AS T1
PIVOT(
MAX(NAME)
FOR OCCUPATION IN (Actor,Doctor,Professor,Singer)
) AS P
ORDER BY Actor


--PIVOT(NAME FOR OCCUPATION IN (Doctor,Professor,Singer,Actor)) AS P

ROLLBACK TRAN

GO

--HERE XML STARTS 
--WE CAN'T HAVE GOOD XML CONTENT IF WE MULTIPLE ROOT ELEMENT

---THIS IS HOW THE XML DATA CAN STORED IN A COLUMN
DECLARE @XML XML

SET @XML = '
<STUDENTRECORD>
<STUDENT>
<NAME>AJAY</NAME>
<MOBILE>7502449969</MOBILE>
</STUDENT>
<STUDENT>
<NAME>ARUN</NAME>
<MOBILE>9802449969</MOBILE>
</STUDENT>
</STUDENTRECORD> '

SELECT @XML;

---WHEN YOU WANA CONVERT THE DATA WHICH IS STORED IN TABLE TO XML

--THIS CODE WILL CREATE THE SINGULAR TAG 
--FOR EACH OF THE ROW BY IT COULMN SCHEMA
--ALL COLUMN VALUE AS ATTRIBUTE
SELECT 
*
FROM 
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
FOR XML RAW('MYROWS')


--THIS WILL CREATE EACH ROW WITH THEIR SCHEMA 
--WILL BE COLUMN BUT AS SEPRATE TAGS
SELECT 
*
FROM 
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
FOR XML RAW('MYROWS') ,ELEMENTS

--NEED TO LEARN IT
--IT JUST SAY THE SQLSERVER TO TYPE IT IN XML FORMAT 
--BUT HERE DOSEN'T MAKE ANY SENSE
SELECT 
*
FROM 
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
FOR XML RAW('MYROWS') ,TYPE




--TO CREATE THE SEPRATE TABLE AND ITS DATA 
--WE CAN USE THE
SELECT 
*
FROM 
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 200 AND 203
FOR XML AUTO

--AUTO WILL COMPRESS INTO SEPARETE TABLE AND ITS VALUE 
--IN THIS CASE  COMMON WILL BE EMPLOYEE NUMBER 
--IF IT HAS ANY DUPLICATES VALUE FR EMPLOYEE NUMBER WILL SEGREGATED 
--SEPARTELY ANOTHER TAG


--TO CHANGE EVERY ATTRIBUTE INTO TAGS USE WITH ELEMENT

SELECT 
*
FROM 
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 200 AND 203
FOR XML AUTO , ELEMENTS


---PATH IN XML
--PATH WILL LET YOU TO CONTROL IN THAT SCHEMMA MORE
--HERE I HAVE CREATED THAT THREE COLUMN AS ATTRIBUTE
SELECT 
--COVERT THIS THREEVALUES AS ATTTRIBUTES 
DATAS.EmployeeNumber AS '@EmployeeNumber',
DATAS.EmployeeFirstName AS '@EmployeeFirstName',
DATAS.EmployeeLastName AS '@EmployeeLastName',
---IT WILL  CREATE SPERATE TAG WRAP AND NESTED THE VALUE WHICH WE MENTION IT
TRANSAC.AMOUNT 'WRAP/AMOUNT',
TRANSAC.DATEOFFTRANSACTION 'WRAP/DATEOFFTRANSACTION'
FROM 
DATAS
LEFT JOIN
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
WHERE DATAS.EmployeeNumber BETWEEN 200 AND 203
FOR XML PATH

---SO FAR WE DO HAVE DUPLICATES FOR IN XML
SELECT 
--COVERT THIS THREEVALUES AS ATTTRIBUTES 
DATAS.EmployeeNumber AS '@EmployeeNumber',
DATAS.EmployeeFirstName AS '@EmployeeFirstName',
DATAS.EmployeeLastName AS '@EmployeeLastName',
---IT WILL  CREATE SPERATE TAG WRAP AND NESTED THE VALUE WHICH WE MENTION IT
(SELECT TRANSAC.AMOUNT 'WRAP/AMOUNT',
TRANSAC.DATEOFFTRANSACTION 'WRAP/DATEOFFTRANSACTION'
FROM 
TRANSAC WHERE TRANSAC.EMPLOYEENUMBER = DATAS.EmployeeNumber
--THIS WILL REDUSE THE DUPLICATES BUT I DON'T KNOW HOW IT IS REDUSING IT
FOR XML PATH (''),TYPE)
FROM 
DATAS
WHERE DATAS.EmployeeNumber BETWEEN 200 AND 203
FOR XML PATH
GO


---QUERY OUT IN XML
DECLARE @X XML

SET @X= '
<BookCatalog>
  <Book>
    <Title>Book Title 1</Title>
    <Author>Author 1</Author>
    <ISBN>978-1234567890</ISBN>
    <PublicationYear>2023</PublicationYear>
  </Book>
  <Book>
    <Title>Book Title 2</Title>
    <Author>Author 2</Author>
    <ISBN>978-0987654321</ISBN>
    <PublicationYear>2021</PublicationYear>
  </Book>
</BookCatalog>
 ';

--PROPERTY CASE SENSITIVE
--This is how we can query out the elements from the 
--xml but it should return the singleton record
SELECT @X.value('(/BookCatalog/Book/Title)[1]','VARCHAR(50)')

--it will return boolean either the record is there or not
SELECT @X.exist('(/BookCatalog/Book/Title)[1]')

GO


--Modify the Query
go

DECLARE @X XML

SET @X= '
<BookCatalog>
  <Book>
    <Title value="1">Book Title 1</Title>
    <Author>Author 1</Author>
    <ISBN>978-1234567890</ISBN>
    <PublicationYear>2023</PublicationYear>
  </Book>
  <Book>
    <Title value="1">Book Title 2</Title>
    <Author>Author 2</Author>
    <ISBN>978-0987654321</ISBN>
    <PublicationYear>2021</PublicationYear>
  </Book>
</BookCatalog>
 ';


 --select @X.value('(/BookCatalog/Book/Title)[1]','varchar(50)')

 --This is responsible of Modifiyng only the attributes
 set @x.modify('replace value of (/BookCatalog/Book/Title/@value)[1] with "ajay kumar"')

 --this is how we can insert the data into the table as well
 set @x.modify('insert <Items>as one</Items> into (/BookCatalog/Book)[1]')

 select @x;







---QUERY TEST
---THIS IS THE PLACE WE NEED TO UNDERSTAND THAT
--- THOUGH WE FETCHING THE RESULT BUT IT'S NOT TRUE
--BECAUSE IN HERE THE COLUMN WILL HAVE THE DIFFERENT 
--DATE FOR TRANSACTION  VEN WE GROUP IT BUT ORGINALLY IT'S NOT POSSIBLE THAT'S WHY WE ARE HAVING THE 
--DIFFERENT RESULT
SELECT 
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,
TRANSAC.DATEOFFTRANSACTION,
STRING_AGG(TRANSAC.AMOUNT,',') AS GROPPCONCAT
FROM 
DATAS
LEFT JOIN 
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATAS.EmployeeNumber,DATAS.EmployeeFirstName,TRANSAC.DATEOFFTRANSACTION

---EXPECTED RESULT
SELECT 
DATAS.EmployeeNumber,
DATAS.EmployeeFirstName,
STRING_AGG(TRANSAC.AMOUNT,',') AS GROUPCONCAT
FROM 
DATAS
LEFT JOIN 
TRANSAC
ON DATAS.EmployeeNumber = TRANSAC.EMPLOYEENUMBER
GROUP BY DATAS.EmployeeNumber,DATAS.EmployeeFirstName

BEGIN TRAN
-- Create the Activities table
CREATE TABLE Activities (
    sell_date DATE,
    product VARCHAR(50)
);

-- Insert data into the Activities table
INSERT INTO Activities (sell_date, product)
VALUES
    ('2020-05-30', 'Headphone'),
    ('2020-06-01', 'Pencil'),
    ('2020-06-02', 'Mask'),
    ('2020-05-30', 'Basketball'),
    ('2020-06-01', 'Bible'),
    ('2020-06-02', 'Mask'),
    ('2020-05-30', 'T-Shirt');
ROLLBACK TRAN


--FOREVER UNDERSTANDING FIRST GROUP IT THEN SELECT IT
SELECT 
SELL_DATE,
COUNT(DISTINCT PRODUCT) AS NUM_SOLD,
STRING_AGG(PRODUCT,',') AS PRODUCT
FROM Activities
GROUP BY SELL_DATE;

-- I THOUGHT I AM ORDERING IT FIRST IT WILL BE A FAILURE
SELECT
SELL_DATE,
COUNT(DISTINCT PRODUCT) AS NUM_SOLD,
STRING_AGG(PRODUCT,',') AS PRODUCT
FROM
(SELECT * FROM Activities
ORDER BY PRODUCT) AS T1
GROUP BY T1.SELL_DATE

--S
SELECT 
SELL_DATE,
COUNT(DISTINCT PRODUCT) AS NUM_SOLD,
STRING_AGG(PRODUCT,',') WITHIN GROUP (ORDER BY PRODUCT) AS PRODUCT
FROM 
(SELECT DISTINCT SELL_DATE,PRODUCT FROM Activities) AS TEMP
GROUP BY SELL_DATE

SELECT * FROM TRANSAC WHERE TRANSAC.EMPLOYEENUMBER  LIKE '%12' OR TRANSAC.EMPLOYEENUMBER LIKE '_200'

DROP TABLE Employee
BEGIN TRAN
CREATE TABLE Employee (
    employee_id INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE Salaries (
    employee_id INT PRIMARY KEY,
    salary INT
);

INSERT INTO Employee (employee_id, name)
VALUES
    (2, 'Crew'),
    (4, 'Haven'),
    (5, 'Kristian');


INSERT INTO Salaries (employee_id, salary)
VALUES
    (5, 76071),
    (1, 22517),
    (4, 63539);

-- 

--FROM
(SELECT 
Employee.employee_id  
FROM
Employee
LEFT OUTER JOIN
Salaries 
ON Employee.employee_id  = Salaries.employee_id
WHERE Salaries.employee_id IS NULL)
UNION
(SELECT 
Salaries.employee_id
FROM
Employee
RIGHT OUTER JOIN
Salaries 
ON Employee.employee_id  = Salaries.employee_id
WHERE Employee.employee_id IS NULL)

SELECT Employee.employee_id
FROM Employee
LEFT JOIN Salaries ON Employee.employee_id = Salaries.employee_id
WHERE Salaries.employee_id IS NULL;

ROLLBACK TRAN



BEGIN TRAN 
-- Create the "Products" table
CREATE TABLE Products (
    product_id INT PRIMARY KEY,
    store1 INT,
    store2 INT,
    store3 INT
);

-- Insert the values into the "Products" table
INSERT INTO Products (product_id, store1, store2, store3)
VALUES
    (0, 95, 100, 105),
    (1, 70, NULL, 80);

SELECT * FROM PRODUCTS
UNPIVOT(PRICE FOR STORE IN ([STORE1],[STORE2],[STORE3])) AS UNPIOVTS

SELECT * FROM PRODUCTS




ROLLBACK TRAN



go
BEGIN TRAN
-- Create the "Tree" table
CREATE TABLE Tree (
    id INT PRIMARY KEY,
    p_id INT
);

-- Insert the values into the "Tree" table
INSERT INTO Tree (id, p_id)
VALUES
    (1, NULL),
    (2, 1),
    (3, 1),
    (4, 2),
    (5, 2);

SELECT
ID,
CASE WHEN P_ID IS NULL THEN 'Root'
     WHEN ID IN (SELECT P_ID FROM TREE) THEN 'Inner'
     ELSE 'Leaf' END AS TYPE
FROM 
TREE
GO
ROLLBACK TRAN

SELECT IIF(1 IN (1,2,3),1,0)




GO


BEGIN TRAN
-- Create the "Visits" table
CREATE TABLE Visits (
    visit_id INT PRIMARY KEY,
    customer_id INT
);

-- Insert values into the "Visits" table
INSERT INTO Visits (visit_id, customer_id)
VALUES
    (1, 23),
    (2, 9),
    (4, 30),
    (5, 54),
    (6, 96),
    (7, 54),
    (8, 54);

-- Create the "Transactions" table
CREATE TABLE Transactions (
    transaction_id INT PRIMARY KEY,
    visit_id INT,
    amount INT
);

-- Insert values into the "Transactions" table
INSERT INTO Transactions (transaction_id, visit_id, amount)
VALUES
    (2, 5, 310),
    (3, 5, 300),
    (9, 5, 200),
    (12, 1, 910),
    (13, 2, 970);

SELECT
customer_id,
COUNT(customer_id) count_no_trans
FROM
VISITS
LEFT JOIN
TRANSACTIONS
ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID
WHERE TRANSACTIONS.VISIT_ID IS NULL
GROUP BY customer_id

ROLLBACK TRAN

SELECT 
EMPLOYEENUMBER AS ID
FROM
TRANSAC
WHERE EMPLOYEENUMBER % 2 = 0 
GROUP BY EMPLOYEENUMBER
HAVING EMPLOYEENUMBER > 100
ORDER BY ID


GO

BEGIN TRAN
-- Create the "Weather" table
CREATE TABLE Weather (
    id INT PRIMARY KEY,
    recordDate DATE,
    temperature INT
);

-- Insert values into the "Weather" table
INSERT INTO Weather (id, recordDate, temperature)
VALUES
    (1, '2015-01-01', 10),
    (2, '2015-01-02', 25),
    (3, '2015-01-03', 20),
    (4, '2015-01-04', 30);


SELECT 
id
FROM
WEATHER AS T1
WHERE T1.temperature  > 
(SELECT 
temperature 
FROM 
WEATHER AS TEMPS
WHERE TEMPS.RECORDDATE =  CONVERT(DATE,DATEADD(DAY,-1,T1.recordDate)))


ROLLBACK TRAN


---CURSOR 
--ROW BASED ACTION TO A TABLE IS CALLED CURSOR
--SET BASED ACTION -- SELECT STATEMENT

--ROW BASED OPERATION IS 
SELECT * FROM STUDENT STUDENT_ID = 1;
--SEPARTELY SELECTED  THERE WILL BE MULTIPLE RESULT SET IN THE TABLE
SELECT * FROM STUDENT STUDENT_ID = 2;




GO

BEGIN TRAN
DECLARE @SD INT 
DECLARE CSR CURSOR FOR 
SELECT 
student_id
FROM
STUDENTS

OPEN CSR 
FETCH NEXT FROM CSR INTO @SD
--FETCH STATUS IS 0 SCUCCESSFULLY DATA HAS BEEN FETCH FROM THE TABLE
WHILE @@FETCH_STATUS = 0
BEGIN
SELECT * FROM STUDENTS WHERE student_id = @SD;
FETCH NEXT FROM CSR INTO @SD
END
CLOSE CSR 
DEALLOCATE CSR



--DONE IT IN CPU

ROLLBACK TRAN

begin tran

--optimizing query 

--Query(RELATIVE TO batch) it's term where it shows the cost of query is total 100% 

select * from Students;

select * from sys.all_objects;


rollback tran


--TABLE SCAN -- WITHOUT INDEX
--INDEX SCAN -- APPLIED INDEX BUT NOT USED IN WHERE CLAUSE
--INDEX SEEK -- APPLIED INDEX USED IN WHERE OR ON CLAUSE WHERE THE FILTER IS APPLIED


begin tran

create table drax
(
name varchar(25),
gender bit 
)

--insert into drax
--values ('Ajay',1),('Vijay',0),('Arjun',1),('Kammal',0),('Dhansush',0)

--it shows table scan 
--before appling index once index is applied it will be showing like index scan 
--because index is for sperate column  not for your column 
select name from drax where name = 'Ajay';

--FILTER INDEX -- ONLY FOR NON CLUSTERD INDEX
--IT KIND OF WAY APPLYING CLUSTERED INDEX FOR CERTAIN ROWS
create nonclustered index IDX_name_gender on drax(name,gender)
where [name] = 'A%';

--JUSTIFICATION
---clusterd index
--not working 
create clustered index IDX_name_gender on drax(name)
where [name] = 'Ajay';



---to apply the index for certain records like Filter indexing
create nonclustered index IDX_name_gender on drax(name,gender)
where [name] = 'Ajay';



--APPLY NON CLUSTERD INDEX
create nonclustered index IDX_name_gender on drax(name,gender)



--index scan because not using indexed column
select * from drax;

--when applying index column on where clause it will perform seek operation it will show 
select * from drax;
select * from drax  where name = 'Ajay';

--when executing both for a table 
--there is no such a Major defference 
--because of the Table records count
select * from drax;
select * from drax  where name = 'Ajay';


--drop table drax
alter table drax
add constraint pk_key Primary key(name)

--clusterde index allows dupplicate 
drop  index [IDX_name] on drax

--key Points to remeber
--unique clustered index doesn't allows a Dupplicate 
--primary key implicitly create UNIQUE clustered index
--re odrder the Data but it DOESNT ALLOW allows duplicate and only one in a table

--one you add the non clustered index it will show as non clustered seek operation
--if you did not performany action or select the specific column in a query it will
--show only as index scan index
select gender from drax  where name = 'Ajay';


---CLUSTERD INDEX ALLOW DUPLICATES 
-- I THOUGHT CLUSTERED INDEX DOESN'T ALLOWS DUPLICATES 
--BUT IT ALLOWS WHERE UNIQUE CLUSTERD INDEX WON'T
BEGIN TRAN
SELECT * FROM DRAX

INSERT INTO DRAX VALUES('Ajay',1);

CREATE CLUSTERED INDEX IDX_NAME ON DRAX(NAME)

SELECT * FROM  DRAX WHERE NAME = 'AJAY'

--DELETE FROM DRAX 
--WHERE NAME = 'AJAY'

ROLLBACK TRAN


---NON CLUSTERD INDEX ALLOW DUPLICATES 
-- I THOUGHT NON-CLUSTERED INDEX DOESN'T ALLOWS DUPLICATES 
--BUT IT ALLOWS WHERE UNIQUE CLUSTERD INDEX WON'T
BEGIN TRAN
SELECT * FROM DRAX

INSERT INTO DRAX VALUES('Ajay',1);

CREATE NONCLUSTERED INDEX IDX_NAME ON DRAX(NAME)

SELECT * FROM  DRAX WHERE NAME = 'AJAY'

SELECT * FROM DRAX 
WHERE NAME = 'AJAY'

ROLLBACK TRAN





SELECT * FROM DRAX


drop index 


select 
rollback tran

--TYPES OF JOIN
--HASH JOIN -- WITHOUT INDEX -- DO TABLE SCAN AND HASH IT BACK
--NESTED LOOP JOIN -- WITHOUT INDEX BUT FLITER APPLIED FOR JOINS
--MERGE JOIN -- INDEX COLUMN ON CLAUSE 

--HASH JOIN
--IN THIS EXAMPLE YOU CAN CLEARLY SEE THE IT TAKES TWO TABLE SCAN 
--AND HASH IT BACK TO ORGINAL TABLE 
--HASH COST WILL BE 92% --INNER
--HASH COST WILL BE 78% --LEFT
--HASH COST WILL BE 79% --RIGHT
BEGIN TRAN
SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
--WHEN YOU REDUSE THE COLMN USING WHERE CLAUSE IT WILL BE CHANGING 
--INTO NESTED LOOP REGARDE LESS OF ONE BIG AND SMALL TABLE 
--WHERE E.EMPLOYEENUMBER IN (123,121,124)
ROLLBACK TRAN


--NESTED LOOP
--APPLICABLE FOR ONE SMALL TABLE WITH ONE BIG TABLE -- PRESUMABLY
--IN THIS EXAMPLE YOU CAN CLEARLY SEE THE IT TAKES TWO TABLE SCAN 
--AND LOOP  IT BACK TO ORGINAL TABLE 
BEGIN TRAN
SELECT * FROM
[dbo].[tblEmployee] as E
LEFT join
[dbo].[tblDepartment] AS D
on E.DEPARTMENT = D.DEPARTMENT AND  D.DEPARTMENT = 'HR'
--WHERE D.DEPARTMENT = 'HR'
ROLLBACK TRAN






--MERGE JOIN


--IN THIS EXAMPLE YOU CAN CLEARLY SEE THE IT TAKES TWO TABLE INDEX SEEK 
--AND MEREGE IT BACK TO ORGINAL TABLE 
--NON CLUSTRED INDEX -- CREATES TABLE SCAN
BEGIN TRAN
CREATE NONCLUSTERED INDEX IDX_NON_CLUSTERED_EMPLOYEENUMBER_EMPTAB ON [dbo].[tblEmployee](EMPLOYEENUMBER)
CREATE NONCLUSTERED INDEX IDX_NON_CLUSTERED_EMPLOYEENUMBER_TRANTAB ON [dbo].[tblTransaction](EMPLOYEENUMBER)
SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
ROLLBACK TRAN

---MEREG JOIN 
--TRY USING CLUSTERD INDEX
--INDEX APPLIED LOOK FOR INDEX SCAN BUT NOT MERGE JOIN
--THOUGH WE ARE USING THAT INDEXED CAOLUMN IN A TABLE
BEGIN TRAN
CREATE CLUSTERED INDEX IDX_NON_CLUSTERED_EMPLOYEENUMBER_EMPTAB ON [dbo].[tblEmployee](EMPLOYEENUMBER)
CREATE CLUSTERED INDEX IDX_NON_CLUSTERED_EMPLOYEENUMBER_TRANTAB ON [dbo].[tblTransaction](EMPLOYEENUMBER)
SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
ROLLBACK TRAN

--MERGE JOIN 
--MERGE JOIN APPLICABLE FOR TABLE WHEN TABLE HAS UNIQUE CLUSTERD INDEX 
--OTHER WISE HASH JOIN WILL HAPPEN ALWAYS
--TRY USING UNIQUE CLUSTERED INDEX 
--APPLYING ON ONE TABLE IS ENOUGH
BEGIN TRAN
CREATE UNIQUE CLUSTERED INDEX IDX_NON_CLUSTERED_EMPLOYEENUMBER_EMPTAB ON [dbo].[tblEmployee](EMPLOYEENUMBER)
--CREATE UNIQUE CLUSTERED INDEX IDX_NON_CLUSTERED_EMPLOYEENUMBER_TRANTAB ON [dbo].[tblTransaction](EMPLOYEENUMBER)
SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
ROLLBACK TRAN

--SARG -- IT'S A SEARCH ARGUMENTS 
--IN AN SIMPLE EXAMPLE => WHERE YEAR(DATEOFBIRTH) =  2020 --IT'S NOT USING THE COLUMN
--DIRECTLY -- IT USED BEHALF OF YEAR FUNCTION -- SO IT'S NOT SARG

--THIS IS SARG
--GOOD SARG WILL BE => WHERE DATEOFBIRTH BETWEEN '2021-01-01' AND '2021-01-31'

--SAME LIKE WHERE SUBSTRING(NAME,1,4) = 'AJAY' --IT'S NOT SARG 
--THIS IS SARG WHERE  NAME LIKE 'AJAY%'

--JUSTIFIYING SARG IS BETTER
--WITHOUT INDEX
--WHERE MADE CALULATION IT WILL BE SLOW  61%
--WHERE WE DOESN'T HAVE ANY CALCULATION IT WILL BE FAST 39%
BEGIN TRAN
SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
WHERE E.EMPLOYEENUMBER / 10 = 34 -- NOT SARG

SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
WHERE E.EMPLOYEENUMBER BETWEEN 340 AND 349 --SARG
ROLLBACK TRAN


--JUSTIFIYING SARG IS BETTER
--WITHOUT INDEX
--WHERE MADE CALULATION IT WILL BE SLOW  61%
--WHERE WE DOESN'T HAVE ANY CALCULATION IT WILL BE FAST 39%
--WITH INDEX
--IT WILL BE TAKING AROUND
--16% FOR CALCULATION   --INDEX APPLIED
--6% FOR WITHOUT CALCULATION --INDEX APPLIED
BEGIN TRAN
CREATE UNIQUE CLUSTERED INDEX IDX_NON_CLUSTERED_EMPLOYEENUMBER_EMPTAB ON [dbo].[tblEmployee](EMPLOYEENUMBER)
SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
WHERE E.EMPLOYEENUMBER / 10 = 34

SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
WHERE E.EMPLOYEENUMBER BETWEEN 340 AND 349
ROLLBACK TRAN

--ANOTHER WAY JUSTIFIYNING THAT SARG IS FASTER
BEGIN TRAN
--CREATE UNIQUE CLUSTERED INDEX IDX_NON_CLUSTERED_EMPLOYEENUMBER_EMPTAB ON [dbo].[tblEmployee](EMPLOYEENUMBER)
SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
WHERE SUBSTRING(E.EmployeeFirstName,1,2) = 'JA' 

SELECT * FROM
[dbo].[tblEmployee] as E
RIGHT join
[dbo].[tblTransaction] AS T
on E.EMPLOYEENUMBER = T.EMPLOYEENUMBER
WHERE E.EmployeeFirstName LIKE 'JA%'
ROLLBACK TRAN

SELECT SUBSTRING(EmployeeFirstName,1,2) FROM tblEmployee


---WITH RECOMPILE WILL CREATE DIFFERENT EXECUTION PLAN 
--EACH TIME EXECUTION OF SP

--- I AM TRY TO CREATE TABLE WITH 6250000 RECORDS HERE 

BEGIN TRAN
SELECT * INTO tblTransactionBig FROM tblTransaction

insert into 
tblTransactionBig
(EmployeeNumber,DateOfTransaction,Amount)
SELECT 
1 AS EmployeeNumber,
tb.DateOfTransaction,
tb.Amount
FROM tblTransaction as tb
cross join
tblTransaction as t
--on 
--TB.EmployeeNumber = T.EmployeeNumber

SELECT * FROM tblTransactionBig WHERE EmployeeNumber = 1;


--COMMIT TRAN

ROLLBACK TRAN


--CREATE A INDEX FOR THE TABLE COLUMN
begin tran
CREATE NONCLUSTERED INDEX 
IDX_CLUSTERED_ON_TBLTRANBIG 
ON [dbo].[tblTransactionBig](EmployeeNumber)

--commit tran


---SMALL CHECK UP IN THE INDEXING 
--WITH CLUSTERED INDEX 1:13 SEC FOR 62500002 --INDEX SEEK
--WITH NON CLUSTERED INDEX 1:13 SEC FOR 62500002 
--INDEX SCAN FOR 1 BUT INDEX SEEK NON CLUSTERED FOR 121
--WITHOUT CLUSTERED INDEX 1:17 SEC  FOR 62500002 -IINDEX SCAN
select * from tblTransactionBig  where EmployeeNumber = 121; 


rollback tran

---THE MAIN PURPOSE OF CALLING PROCEDURE 
--IT'S CATCH THE EXECUTION PLAN
--EXCUTE FOR OTHER TIME INVOKATION
--IT COMPILE ONLY ONE TIME I GUESS


---creating PROCEDURE
--THE MAIN MOTO OF RECOMPILE IN SOME CASES U NEED TO
--CREATE  DIFFERENT EXECUTION PLAN BASED ON INPUT PARAMETER 
--IN THIS CASE OF SP FOR EMPLOYEENUMBER 1 IT WILL EXECUTE 
--TABLE SCAN 
--FOR EMPNUMBER 121 IT EXECUTES INDEX SEEK NON CLUSTERED
--REMEBER FIRST YOU SHOULD EXECUTE THE 1 PARAMETER


--WITHOUT RECOMPLIE
GO
BEGIN TRAN
DROP PROCEDURE SEARCHEMPLOYEE
GO
CREATE PROCEDURE SEARCHEMPLOYEE(@EMPLOYEENUMBER INT)
AS
BEGIN
SELECT
*
FROM
tblEmployee E
RIGHT JOIN 
tblTransactionBig TB
ON 
E.EMPLOYEENUMBER = TB.EMPLOYEENUMBER
WHERE E.EMPLOYEENUMBER = @EMPLOYEENUMBER
END

--INDEX SEEK
EXEC SEARCHEMPLOYEE 126


--INDEX SCAN
EXEC SEARCHEMPLOYEE 1



--WITH RECOMPILE 
--DIFF NAME OF SP
CREATE PROCEDURE SEARCHEMPLOYEE_RECOMPILE(@EMPLOYEENUMBER INT)
WITH RECOMPILE
AS
BEGIN
SELECT
*
FROM
tblEmployee E
RIGHT JOIN 
tblTransactionBig TB
ON 
E.EMPLOYEENUMBER = TB.EMPLOYEENUMBER
WHERE E.EMPLOYEENUMBER = @EMPLOYEENUMBER
END

--INDEX SEEK
EXEC SEARCHEMPLOYEE_RECOMPILE 126

--TABLE SCAN
EXEC SEARCHEMPLOYEE_RECOMPILE 1



GO

---HINTS IN SQLSERVER
--WITH LOCK --WHICH WILL FETCH THE RECORD WHICH IT NOT COMMITTE 
--IN SIMPLE TERM IF A TABLE IN TRANSACTION BUT IT'S NOT COMMITED
--OR A ROLLBACK THAT RECORD WON'T BE THERE IN 

-- I AM GOONA BEGIN THE TRANACTION FOR A UPDATE
--IN EMPLOYEE TABLE AND TRY TO ACCESS THE RECORD IN THE TABLE 
--WITHOUT COMPLETING IT TRAN 
BEGIN TRAN
UPDATE tblEmployee
SET Department = 'NONE'
WHERE tblEmployee.EmployeeNumber = 658

--TRAN SACTION AND ROLLBACK AND COMMIT WILL HAPPEN ONLY SESSON BASED
--IF BEGIN TRAN STARTS WITH IN A SESSION YOU CAN ROLLBACK
ROLLBACK

---I TRY TO ACCESS THE TABLE RECORD WITH IN THE SAME SESSION
--LIKE SAME QUERY PAGE
--ITS ACCESSIBLE AND DATAS ARE UPDATED AS WELL
--BUT IF I TRY TO ACCESS THE OTHER SESSION OR OTHER PAGE 
--IT WILL BE LOADING FOREVER
--IN THAT CASE YOU CAN USE NOLOCK 
--WHICH WILL GIVE YOU THE UPDATED RECORD WITH COMMITED TRAN SAME LIKE ACCESING THE 
--SESSION
SELECT 
*
FROM
tblTransaction
LEFT JOIN
tblEmployee
ON tblTransaction.EmployeeNumber = tblEmployee.EmployeeNumber
WHERE DEPARTMENT = 'HR'

--DIRTY READ LATES UPDATED RECORD
SELECT 
*
FROM
tblTransaction
LEFT JOIN
tblEmployee WITH (NOLOCK)
ON tblTransaction.EmployeeNumber = tblEmployee.EmployeeNumber
WHERE tblEmployee.EmployeeNumber = 658

--HINTS
--MEREG,LOOP,HASH
--IT'S FOR DEBUGGIG WHICH ONE IS FASTER
SELECT 
*
FROM
tblTransaction
LEFT HASH JOIN
tblEmployee
ON tblTransaction.EmployeeNumber = tblEmployee.EmployeeNumber
WHERE DEPARTMENT = 'HR'


SELECT 
*
FROM
tblTransaction
LEFT LOOP JOIN
tblEmployee
ON tblTransaction.EmployeeNumber = tblEmployee.EmployeeNumber
WHERE DEPARTMENT = 'HR'


SELECT 
*
FROM
tblTransaction
LEFT MERGE JOIN
tblEmployee
ON tblTransaction.EmployeeNumber = tblEmployee.EmployeeNumber
WHERE DEPARTMENT = 'HR'

GO

--SET STATISTICS IO ON
--WHICH WILL SHOW LOGICAL READ AND 

SET STATISTICS IO ON
--able 'tblEmployee'. Scan count 1, logical reads 9, physical reads 9,
-- page server reads 0, read-ahead reads 0, page server read-ahead reads 0,
-- lob logical reads 0, lob physical reads 0, lob page server reads 0,
-- lob read-ahead reads 0, lob page server read-ahead reads 0.
--Table 'tblTransaction'. Scan count 1, logical reads 7, physical reads 7, 
--page server reads 0, read-ahead reads 0, page server read-ahead reads 0,
-- lob logical reads 0, lob physical reads 0, lob page server reads 0, 
--lob read-ahead reads 0, lob page server read-ahead reads 0.

--LOGICAL READS --SAYS THE DATA READ FROM THE CAHE
--Scan count 1 -- WITHOUT INDEX SO IT DOES SCAN ONE 
--BECAUSE OF ONE VALYE IN WHERE CLAUSE
--physical reads 9 -- READED FRO HARD DISC
--LOB OR BLOB - TEXT IMAGE VARCHAR(MAX) THOSES THINGS



--BLOB -- ARE NOT LOCATED IN THE LEAF NODE JUST REFERENCE IS THERE 
--IT REACHES THE LEAF NODE TO GET THE REFERENCE AND LOOKING 
--THAT OBJECT IN THE REFERENCE 
--MENTIONED
SELECT 
*
FROM
tblTransaction
LEFT MERGE JOIN
tblEmployee
ON tblTransaction.EmployeeNumber = tblEmployee.EmployeeNumber
WHERE DEPARTMENT = 'HR'


--SET STATISTICS TIME ON 
--WILL GIVE THE CPU CONUSMEING TIME


--WHAT IS TRANSACION CHARACTERSTICS
--ACID
--AUTOMICITY --SINGLE UNIT OF ACTION
--CONSISTENCY --EVERY ACTION RELEVANT THAT ACTION SHOULD BE PERFORMED
--ISOLATION ONE TRANSACTION WILL BE ISOLATED FROM OTHER
--ISO EXAMPLE -- TRANSACTION FOR ONE TABLE EMPLOYEE OTHER SESSION TRANSACTION CAN'T 
--ACCESS IT
--DURABILITY -- COMMITED CAN'T CHANGE





--IMPLICIT TRANSAC
--NORMAL UPDATE STATEMENT WILL INTIATE TRANSACTION IMPLICITLLY

--TRANSACTION ONCE BEGIN IT SHOULD BE COMMITED OR ROLLBACK
--OTHER WISE YOU CAN'T ACCESS THE THAT ROW IN OTHER SESSION
--WHAT IF THE TRAN SACTION DOESN'T AFFECT THE ROW OR TABLE 
--IT DOESN'T AFFECT OTHER SESSION

--EXAMPLE 
--UPDATE TBLEMPLOYEE SET EMPLOYEENUMBER = 120 WHERE EMPLOYEEENUMBER = 0;
--THERE IS NO EMPLOYEE HAVE O EMPLOYEENUMBER SO IT WON'T GET AFFECTED



--NESTED TRAN
--AM COMMITING THE TRANSACTION IN NESTED TRAN
--IF ROLLBACK IN NESTED TRAN IT WILL ROLLBACK THE ENTIRE TRAN - 3 2-EXPLICIT 1-IMPLICIT
SELECT @@TRANCOUNT --IT GIVE THE LEVEL TRANSACTION
BEGIN TRAN
SELECT @@TRANCOUNT
BEGIN TRAN
SELECT @@TRANCOUNT
UPDATE STOCKS SET PRODUCTNAME = 'SOAP IN' WHERE PRODUCTNAME = 'SOAP';
SELECT * FROM STOCKS
COMMIT TRAN
ROLLBACK TRAN


--TO JUSTIFY THAT ONLY ONE ROLLBACK FOR ALL TRAN
SELECT @@TRANCOUNT --IT GIVE THE LEVEL TRANSACTION
BEGIN TRAN
SELECT @@TRANCOUNT
BEGIN TRAN
SELECT @@TRANCOUNT
UPDATE STOCKS SET PRODUCTNAME = 'SOAP IN' WHERE PRODUCTNAME = 'SOAP';
SELECT * FROM STOCKS
ROLLBACK TRAN
SELECT @@TRANCOUNT
ROLLBACK TRAN
SELECT @@TRANCOUNT


--SHARED LOCK
--NO OTHER TRANSACTION IS MODIFY THE DATA
--ALLOW CURRENT TRAN TO READ
--RELASED AS SOON AS READ


--UPDATE LOCK(DEADLOCK)
--TWO TRAN UPDATING THE SAME TABLE 
--COULD NOT BE DONE 
--ONCE IT READING BEFORE UPDATING THAT IS UPDATE LOCK
--THE OTHER STEP IS UPDATING IT IS SHARED LOCK


--EXCLUSIVE LOCK NO OTHER --TRANSACTION CAN MODIFY OR READ THE DATA








--SHARED LOCK
--IT LOCKS THE ENTIRE TABLE
BEGIN TRAN
SELECT * FROM DATAS
ROLLBACK TRAN


--UPDATE LOCK
--TRY WITH TWO QUERY SHEET
--FIRST APPLY SHARED LOCK THEN IT APPLY UPDATE LOCK
--WHEN ALTER TABLE IN ONE SESSION WE CAN'T ACCESS IN OTHER 
--IT JUST BECAUSE OF WE CAN'T APPLY SHARED LOCK AGAIN ON THE TABLE
BEGIN TRAN
UPDATE STOCKS SET PRODUCTNAME = 'SOAP IN' WHERE PRODUCTNAME = 'SOAP';
WAITFOR DELAY '00:00:20'
ROLLBACK TRAN

---WHAT IF THE LOCKS WOULD NOT HAVE HAPPEN IN SQL SERVER
--1.LOST OF UPDATES --FIRST UPDATES AND SECOND PERSON UPDATES THE TABLE  -FIRST PERSON UPDATES WILL BE LOST
--2.UNCOMMITED DEPENDECY -- THE PERSON CAN READ THE UNCOMMITED DEPENDENCY
--3.INCONSISTENT ANALYSIS
--4.PHANTOM READS
--MISSING DOUBLE READ CAUSED BY ROW UPDATES
--MISSING ONE OR MORE ROW THAT WE WEREN'T TARGET OF UPDATE


--TRANSACTION  AND IT'S ISOLATION LEVEL
--READ COMMITED IS THE DEFAULT ISOLATION LEVEL
--WHERE YOU CAN'T READ THE UNCOMMITED TRANSACTION

--2. READ UNCOMMITED(DIRTY READ) --ALLOWS THE USER TO MODIFY THE DATA
--FROM ONE TRAN AND OTHER TRAN CAN READ THE DATA BUT COULD NOT UPDATE IT

--3.REPEATABLE READS WON'T LET YOU TO READ OR CHANAGE IN OTHER TRANSACTION 
--BUT RATHER YOU CAN'T READ IT AGAIN

---READ UNCOMMITED
--HERE I WNAT TO READ BUT IN OTHER PAGE I MA CHANGING IT 
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

BEGIN TRAN
--- I MA TRY TO ACCESS WITH SETING READ UNCOMMITED IT LOADS A LOT
--WHEN I SETU[ I ACN ABLE TO READ THE UPDATED DATA 
--THIS IS CALLED US DIRTY READ
--HOW MUCH IT UPDATED BEFORE COMIITED IT YOU CAN ABLE TO SEE THOSES
--DATA

--ISSUE --WHEN THEY REVERT BACK YOU CAN'T SEE THE DATA BACK
--YOU HAVE TO RE SUN IT
SELECT * FROM tblEmployee --WHERE EMPLOYEENUBER = 123

ROLLBACK TRAN


--THIS IS WHAT I WRRITEN IN OTHER TABLE
BEGIN TRAN
UPDATE tblEmployee
SET EmployeeNumber  = 122 WHERE EmployeeNumber = 123; 

ROLLBACK TRAN

---REPEATABLE EAD

--IT WONT ALLOWS THE OTHER TRABASCTION TO READ OR MODIFY THE DATA
--BUT IT ALLOWS TO INSERT IT 
--IF THE RECORD IS INSERTED DURING THE REAPETABLE READ TRANSACTION
--IT WON'T READ AT THE FIRST BUT IT WILL READ AT THE LAST

SET TRANSACTION ISOLATION LEVEL REPEATABLE READ

BEGIN TRAN
SELECT * FROM tblEmployee;
WAITFOR DELAY '00:00:20'
SELECT * FROM tblEmployee;
ROLLBACK TRAN


---THIS WHAT I AM DOING IN OTHER SECTION 
--READ OR UPDATE NOT POSSIBLE WHERE US INSERT IS POSSIBLE THAT'S WHAT
---CALLED AS PHANTOM READ
BEGIN TRAN
UPDATE tblEmployee
SET EmployeeNumber  = 122 WHERE EmployeeNumber = 123; 

ROLLBACK TRAN

--JUSTIFY INSERT IS POSSIBLE 
--ISSUE IT WILL READ THE INSERTED DATA LIKE HOW MUCH IT INSERTED 
--BUT IT WAIT FOR THE OTHER TRANSACTION WHICH IS DOING THE INSERTION
--ONCE IT COMPLETED IT CAN READ THAT DATA UNTILL REPEATABLE READ TRANASCTION LOADS OR WAITS
BEGIN TRAN
--UPDATE tblEmployee
--SET EmployeeNumber  = 122 WHERE EmployeeNumber = 123; 

INSERT INTO [dbo].[tblEmployee]
           ([EmployeeNumber]
           ,[EmployeeFirstName]
           ,[EmployeeMiddleName]
           ,[EmployeeLastName]
           ,[EmployeeGovernmentID]
           ,[DateOfBirth]
           ,[Department])
     VALUES
           (1001
           ,'AJ'
           ,'R'
           ,'K'
           ,'KJ@@#$1'
           ,GETDATE()
           ,'mech')
COMMIT 

ROLLBACK TRAN

---READ SERIALIZE

SET TRANSACTION  ISOLATION LEVEL SERIALIZABLE
-- I COULD NOT READ OR UPDATE OR DELETED

BEGIN TRAN
SELECT * FROM tblEmployee;
WAITFOR DELAY '00:00:20'
SELECT * FROM tblEmployee;
ROLLBACK TRAN

---THIS WAHT I  WRIITEN IN THE OTHER PAGES 
---IT WILL NOT LET YOU TO INSERT UPDATE OR DELETE
--SEVERE LEVEL OF ISOLATION
BEGIN TRAN
--UPDATE tblEmployee
--SET EmployeeNumber  = 122 WHERE EmployeeNumber = 123; 

INSERT INTO [dbo].[tblEmployee]
           ([EmployeeNumber]
           ,[EmployeeFirstName]
           ,[EmployeeMiddleName]
           ,[EmployeeLastName]
           ,[EmployeeGovernmentID]
           ,[DateOfBirth]
           ,[Department])
     VALUES
           (1001
           ,'AJ'
           ,'R'
           ,'K'
           ,'KJ@@#$1'
           ,GETDATE()
           ,'mech')

DELETE FROM TBLEMPLOYEE
WHERE EmployeeNumber = 1001
COMMIT 


--SNAPSHOT ISOLATION LEVEL IS TIMING CONSUMING THAT'S WHY THIS GUY ISN'T COVERED THAT
--I NEED TO LOOK AT ON MY OWN

---DMVS --INDEX RELATED DYNAMIC VIEWS AND CONTROL

---INDEX USAGE STATUS
--THIS OBJECT LIST OU THE DATA RELEVANT TO THE DATABASE
--THE MAIN MOTO OF IT YOU CAN JOIN WITH INDEX OBJECT TO DROP WHICH NOT USED LONG TIME
--SO YOU CAN DROP THAT KIND OF INDEX 
SELECT 
DB_NAME(database_id),
OBJECT_NAME(OBJECT_ID) 
,*
FROM
SYS.dm_db_index_usage_stats
WHERE DATABASE_ID = DB_ID()














